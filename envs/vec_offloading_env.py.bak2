import gymnasium as gym
import numpy as np
import os
from collections import deque, defaultdict
from configs.config import SystemConfig as Cfg
from envs.modules.channel import ChannelModel
from envs.modules.queue_system import FIFOQueue
from envs.entities.vehicle import Vehicle
from envs.entities.rsu import RSU
from envs.entities.task_dag import DAGTask
from envs.services.comm_queue_service import CommQueueService
from envs.services.cpu_queue_service import CpuQueueService
from envs.services.dag_completion_handler import DagCompletionHandler
from envs.rl.obs_builder import ObsBuilder
from envs.rl.reward_engine import RewardEngine
from envs.audit.trace import TraceCollector
from envs.audit.stats_collector import StatsCollector
from utils.dag_generator import DAGGenerator
from utils.reward_stats import RewardStats, ReservoirSampler


# =====================================================================
# [FIFO队列系统] 数据结构定义
# =====================================================================

class TransferJob:
    """
    [通信任务] 单个传输job（INPUT或EDGE）
    
    职责：
    - 记录传输来源/目标/剩余数据量
    - 区分INPUT（动作功率）与EDGE（固定最大功率）
    - 跟踪传输进度与时间戳
    """
    def __init__(self, kind, src_node, dst_node, owner_vehicle_id, subtask_id,
                 rem_bytes, tx_power_dbm, link_type, enqueue_time, parent_task_id=None):
        """
        Args:
            kind: "INPUT" 或 "EDGE"
            src_node: ("VEH", i) 或 ("RSU", j)
            dst_node: ("RSU", j) 或 ("VEH", k)
            owner_vehicle_id: 该DAG属于哪辆车
            subtask_id: INPUT对应本subtask；EDGE对应child_id
            rem_bytes: 剩余字节数
            tx_power_dbm: 发射功率（INPUT=动作映射；EDGE=MAX）
            link_type: "V2I" 或 "V2V"
            enqueue_time: 入队时间
            parent_task_id: EDGE必须有；INPUT为None
        """
        self.kind = kind
        self.src_node = src_node
        self.dst_node = dst_node
        self.owner_vehicle_id = owner_vehicle_id
        self.subtask_id = subtask_id
        self.parent_task_id = parent_task_id
        self.rem_bytes = rem_bytes
        self.tx_power_dbm = tx_power_dbm
        self.link_type = link_type
        
        # 时间戳
        self.enqueue_time = enqueue_time
        self.start_time = None
        self.finish_time = None
        
        # 本step统计
        self.step_time_used = 0.0
        self.step_bytes_sent = 0.0
    
    def get_unique_key(self):
        """获取唯一键（用于EDGE去重）"""
        if self.kind == "EDGE":
            return (self.owner_vehicle_id, self.subtask_id, self.parent_task_id)
        else:
            return (self.owner_vehicle_id, self.subtask_id, "INPUT")


class ComputeJob:
    """
    [计算任务] 单个计算job
    
    职责：
    - 记录计算位置（车辆或RSU的处理器ID）
    - 跟踪剩余计算量与进度
    - 支持多处理器并行（RSU）
    """
    def __init__(self, owner_vehicle_id, subtask_id, rem_cycles, exec_node,
                 processor_id, enqueue_time):
        """
        Args:
            owner_vehicle_id: 任务所属车辆ID
            subtask_id: 子任务ID
            rem_cycles: 剩余计算量（cycles）
            exec_node: ("VEH", i) 或 ("RSU", j)
            processor_id: 车辆恒0；RSU为[0..P-1]
            enqueue_time: 入队时间
        """
        self.owner_vehicle_id = owner_vehicle_id
        self.subtask_id = subtask_id
        self.rem_cycles = rem_cycles
        self.exec_node = exec_node
        self.processor_id = processor_id
        
        # 时间戳
        self.enqueue_time = enqueue_time
        self.start_time = None
        self.finish_time = None
        
        # 本step统计
        self.step_time_used = 0.0
        self.step_cycles_done = 0.0


def compute_absolute_reward(dT_rem, t_tx, power_ratio, dt, p_max_watt, reward_min, reward_max, hard_triggered=False, illegal_action=False):
    """
    绝对潜在值奖励：仅依赖剩余时间差与动作功率，便于权重外调。
    
    能耗计算说明：
    - 当前实现：E = (p_tx + p_circuit) * dt （传输能耗）
    - 计算能耗：E_comp = K * f^2 * cycles （未显式计入）
    - 设计理由：
      1. 对于单车辆offloading决策，传输能耗是主要因素
      2. Local执行无传输能耗，只有固定计算能耗
      3. RSU/V2V执行的远程计算能耗由远程节点承担
    - 扩展方向：如需系统级能耗优化，可传入comp_cycles和cpu_freq参数
    """
    dT_clipped = float(np.clip(float(np.nan_to_num(dT_rem, nan=0.0, posinf=0.0, neginf=0.0)), Cfg.DELTA_CFT_CLIP_MIN, Cfg.DELTA_CFT_CLIP_MAX))
    dT_eff = dT_clipped - float(dt)
    t_tx_clipped = float(np.clip(np.nan_to_num(t_tx, nan=0.0, posinf=0.0, neginf=0.0), 0.0, dt))
    p_watt = float(np.nan_to_num(p_max_watt, nan=0.0, posinf=0.0, neginf=0.0))
    p_circuit = float(getattr(Cfg, "P_CIRCUIT_WATT", 0.0))
    p_tx = float(np.nan_to_num(power_ratio, nan=0.0, posinf=0.0, neginf=0.0)) * p_watt
    # 能耗组成：传输能耗（当前）+ 计算能耗（可扩展）
    e_step = (p_tx + p_circuit) * float(dt)
    e_max = max((p_watt + p_circuit) * float(dt), 1e-12)
    energy_norm = float(np.clip(e_step / e_max, 0.0, 1.0))
    # 线性组合：时间收益 - 能耗惩罚；权重完全由配置驱动
    reward = reward_min if (hard_triggered or illegal_action) else (Cfg.DELTA_CFT_SCALE * dT_clipped - Cfg.DELTA_CFT_ENERGY_WEIGHT * energy_norm)
    reward = float(np.clip(reward, reward_min, reward_max))
    return reward, {
        "dT": dT_clipped,
        "dT_eff": dT_eff,
        "energy_norm": energy_norm,
        "t_tx": t_tx_clipped,
        "dt_used": float(dt),
    }


class VecOffloadingEnv(gym.Env):
    """车联网边缘计算任务卸载环境 (Gymnasium接口)

    核心特性:
    - 多车辆协同任务卸载: 每个车辆作为独立智能体，拥有独立DAG任务
    - 任务依赖感知: 子任务间存在数据依赖关系，需考虑传输时间
    - 动态V2V通信: 车辆间通信受距离和信道条件影响
    - RSU边缘计算: 可选择将任务卸载到RSU服务器处理

    状态空间 (Observation Space):
    - node_x: 子任务特征 (计算量、剩余数据、状态、入度、出度、剩余时间、紧急度)
    - self_info: 自身状态 (速度、等待时间、CPU频率、信道质量、位置)
    - rsu_info: RSU负载信息
    - adj: DAG邻接矩阵 (任务依赖关系)
    - neighbors: 邻居车辆特征 (固定维度填充)
    - task_mask: 可调度任务掩码 (用于Critic)
    - target_mask: 动作目标掩码 (Local/RSU/V2V)，仅对应当前选中的任务
    - subtask_index: 当前环境自动选择的任务索引 (标量)

    动作空间 (Action Space):
    - target: 卸载目标 (0=Local, 1=RSU, 2+k=Vehicle k)
    - subtask: 要调度的子任务索引
    - power: 传输功率控制

    奖励设计:
    - CFT奖励: 任务完成时间越短越好
    - 拥堵惩罚: V2V/V2I信道拥塞时产生惩罚
    """

    def __init__(self, config=None):
        """初始化环境
        
        Args:
            config: 配置类（可选，默认使用全局Cfg）
        """
        # 使用传入的config或全局Cfg
        if config is not None:
            self.config = config
        else:
            from configs.config import SystemConfig as Cfg
            self.config = Cfg
        
        self.channel = ChannelModel()
        self.dag_gen = DAGGenerator()
        self.vehicles = []
        self.time = 0.0
        
        # RSU实体列表（道路模型：等间距线性部署）
        self.rsus = []
        self._init_rsus()
        
        # CFT计算缓存
        self.last_global_cft = 0.0
        self._cft_cache = None
        self._cft_cache_time = 0.0
        self._cft_cache_valid = False
        self._cft_state_hash = None
        
        # 通信速率和距离缓存（用于性能优化）
        self._comm_rate_cache = {}
        self._cache_time_step = -1.0
        self._dist_matrix_cache = None
        self._dist_matrix_time = -1.0
        self._rsu_dist_cache = {}
        self._last_candidates = {}
        self._last_rsu_choice = {}
        self._reward_stats = RewardStats(sample_size=self.config.STATS_RESERVOIR_SIZE, seed=self.config.STATS_SEED)
        self._episode_id = 0
        self._episode_steps = 0
        self._rate_sampler_v2i = ReservoirSampler(size=self.config.RATE_RESERVOIR_SIZE, seed=self.config.STATS_SEED)
        self._rate_sampler_v2v = ReservoirSampler(size=self.config.RATE_RESERVOIR_SIZE, seed=self.config.STATS_SEED)
        self._rate_norm_v2i = self.config.NORM_MAX_RATE_V2I
        self._rate_norm_v2v = self.config.NORM_MAX_RATE_V2V
        self._rate_min_samples = self.config.RATE_MIN_SAMPLES
        # 通信推进服务（行为等同于原有Phase3推进，后续可独立成模块）
        self._comm_service = CommQueueService(self.channel, self.config)
        # 计算推进服务（行为等同于原有Phase4推进，后续可独立成模块）
        self._cpu_service = CpuQueueService(self.config)
        # DAG完成处理器（阶段5已集成）
        self._dag_handler = DagCompletionHandler(self.config)
        # 观测构造器（阶段6框架，当前未启用）
        self._obs_builder = ObsBuilder(self.config)
        # 奖励引擎（阶段6框架，当前未启用）
        self._reward_engine = RewardEngine(self.config)
        # Trace收集器（阶段7，默认关闭）
        self._trace_collector = TraceCollector(enabled=False)
        # 统计收集器（阶段7，默认开启）
        self._stats_collector = StatsCollector(enabled=True)
        self._episode_dT_eff_values = []
        self._episode_energy_norm_values = []
        self._episode_t_tx_values = []
        self._episode_task_durations = []  # [新增] 追踪真实任务完成时间（物理指标）
        self._last_obs_stamp = None
        # [P2性能统计] 运行期累积器
        self._p2_active_time = 0.0
        self._p2_idle_time = 0.0
        self._p2_deltaW_active = 0.0
        self._p2_zero_delta_steps = 0
        
        # [审计系统] 12项核心指标收集
        self._audit_step_info = {}
        # [Deadline检查计数] 用于诊断是否触发deadline判定
        self._audit_deadline_checks = 0
        self._audit_deadline_misses = 0
        # [P2性能统计] 仅在active时间段统计服务速率
        self._active_time_steps = []  # 记录active_tasks>0的步数
        self._delta_w_active = []  # 对应步的计算量减少
        self._audit_v2v_lifecycle = {
            'tx_started': set(),    # (owner_id, subtask_id)
            'tx_done': set(),
            'received': set(),
            'added_to_active': set(),
            'cpu_finished': set(),
            'dag_completed': set()
        }
        self._audit_task_registry = {}  # {(owner, subtask): {'state': , 'host': }}

        # 归一化常数（预先计算倒数以提高性能）
        self._inv_map_size = 1.0 / self.config.MAP_SIZE
        self._inv_max_nodes = 1.0 / self.config.MAX_NODES
        self._inv_max_cpu = 1.0 / self.config.NORM_MAX_CPU
        self._inv_max_comp = 1.0 / self.config.NORM_MAX_COMP
        self._inv_max_data = 1.0 / self.config.NORM_MAX_DATA
        self._inv_max_wait = 1.0 / self.config.NORM_MAX_WAIT_TIME
        self._inv_max_rate_v2i = 1.0 / self.config.NORM_MAX_RATE_V2I
        self._inv_max_rate_v2v = 1.0 / self.config.NORM_MAX_RATE_V2V
        self._inv_max_velocity = 1.0 / self.config.MAX_VELOCITY
        self._inv_v2v_range = 1.0 / self.config.V2V_RANGE
        self._mean_comp_load = self.config.MEAN_COMP_LOAD
        self._max_rsu_contact_time = self.config.RSU_RANGE / max(self.config.VEL_MIN, 1e-6)
        self._max_v2v_contact_time = self.config.V2V_RANGE / max(self.config.VEL_MIN, 1e-6)
        self._last_candidates = {}
        self._last_rsu_choice = {}
        # 动态车辆统计：记录整个episode出现过的车辆ID
        self._vehicles_seen = set()
        self._last_obs_stamp = None
        
        # =====================================================================
        # [Gymnasium接口] 定义动作空间和观测空间
        # =====================================================================
        # 动作空间：Tuple of MultiDiscrete (每个车辆一个动作)
        # 每个车辆的动作: [target_id, power_ratio_level]
        # - target_id: 0=Local, 1=RSU, 2...(2+MAX_NEIGHBORS-1)=V2V邻居
        # - power_ratio_level: 离散功率等级 [0, NUM_POWER_LEVELS-1]
        single_agent_action_space = gym.spaces.MultiDiscrete([
            self.config.MAX_TARGETS,  # target选择
            self.config.NUM_POWER_LEVELS  # power_ratio等级
        ])
        self.action_space = gym.spaces.Tuple([single_agent_action_space] * self.config.NUM_VEHICLES)
        
        # 观测空间：Dict空间（具体维度在reset后确定）
        # 这里定义一个占位符，实际维度在reset()后根据DAG大小动态确定
        self.observation_space = gym.spaces.Dict({
            'node_x': gym.spaces.Box(low=-np.inf, high=np.inf, shape=(self.config.MAX_NODES, 7), dtype=np.float32),
            'self_info': gym.spaces.Box(low=-np.inf, high=np.inf, shape=(5,), dtype=np.float32),
            'rsu_info': gym.spaces.Box(low=-np.inf, high=np.inf, shape=(self.config.NUM_RSU,), dtype=np.float32),
            'adj': gym.spaces.Box(low=0, high=1, shape=(self.config.MAX_NODES, self.config.MAX_NODES), dtype=np.float32),
            'neighbors': gym.spaces.Box(low=-np.inf, high=np.inf, shape=(self.config.MAX_NEIGHBORS, 4), dtype=np.float32),
            'task_mask': gym.spaces.Box(low=0, high=1, shape=(self.config.MAX_NODES,), dtype=np.float32)
        })
        
        # =====================================================================
        # [FIFO队列系统] 初始化队列容器
        # =====================================================================
        # 通信队列：每个发送实体维护两条并行FIFO队列（V2I与V2V）
        # key格式: ("VEH", vehicle_id) 或 ("RSU", rsu_id)
        self.txq_v2i = {}  # {tx_node: deque[TransferJob]}
        self.txq_v2v = {}  # {tx_node: deque[TransferJob]}
        
        # 计算队列：每个处理器维护一个FIFO队列
        # 车辆: veh_cpu_q[vehicle_id] = deque[ComputeJob]
        # RSU: rsu_cpu_q[rsu_id][processor_id] = deque[ComputeJob]
        self.veh_cpu_q = {}  # {vehicle_id: deque[ComputeJob]}
        self.rsu_cpu_q = {}  # {rsu_id: {processor_id: deque[ComputeJob]}}
        
        # EDGE去重：防止同一EDGE重复创建
        # key = (owner_vehicle_id, child_id, parent_id)
        self.active_edge_keys = set()
        
        # [数值trace] 端到端核验（默认关闭）
        self.DEBUG_TRACE_NUMERIC = False
        self.numeric_trace = []
        self.step_idx = 0
        
        # 能耗账本：严格分离INPUT/EDGE/本地计算/RSU计算
        self.E_tx_input_cost = {}    # INPUT上传能耗（纳入成本/奖励）
        self.E_tx_edge_record = {}   # EDGE传输能耗（仅记录，不纳入成本）
        self.E_cpu_local_cost = {}   # 本地计算能耗（纳入成本/奖励）
        self.CPU_cycles_local = {}   # 本地计算量（记录）
        self.CPU_cycles_rsu_record = {}  # RSU计算量（仅记录）
        
        # =====================================================================
        # 单位一致性检查（Units Sanity Check）
        # =====================================================================
        # 验证数据量（bits）和带宽（Hz -> bps）单位一致性
        mean_data_bits = (self.config.MIN_DATA + self.config.MAX_DATA) / 2  # bits
        mean_bandwidth = self.config.BW_V2I / max(self.config.NUM_VEHICLES // 5, 1)  # Hz (shared)
        # 假设SINR=10 (10dB) → log2(11)≈3.46
        typical_sinr = 10.0
        typical_rate_bps = mean_bandwidth * np.log2(1 + typical_sinr)  # bps
        typical_tx_time = mean_data_bits / typical_rate_bps  # seconds
        
        assert typical_tx_time > 0.01, (
            f"❌ 单位缩放错误：典型传输时间为 {typical_tx_time*1000:.2f}ms < 10ms！"
            f"请检查 DATA_SIZE (当前:{self.config.MIN_DATA:.2e}-{self.config.MAX_DATA:.2e} bits) "
            f"和 BW_V2I (当前:{self.config.BW_V2I:.2e} Hz) 的单位是否一致。"
        )
        assert typical_tx_time < 1.0, (
            f"⚠️  单位缩放警告：典型传输时间为 {typical_tx_time:.2f}s > 1s，"
            f"可能导致任务超时。考虑增加带宽或减少数据量。"
        )

    def _get_node_delay(self, node):
        """
        统一获取节点的延迟估计（处理器共享模型）
        
        Args:
            node: Vehicle or RSU实例
        Returns:
            float: 估计延迟（秒）- 当前负载下的平均剩余执行时间
        
        注意：处理器共享模型中，新任务立即开始执行（无等待），
        但速度会因负载增加而变慢。此函数返回的是当前平均负载延迟。
        """
        if hasattr(node, 'get_estimated_delay'):
            # 使用新的处理器共享模型
            return node.get_estimated_delay()
        else:
            # 向后兼容：使用旧的FIFO模型
            if hasattr(node, 'task_queue'):
                return node.task_queue.get_estimated_wait_time(node.cpu_freq)
            return 0.0

    def _simulate_enqueue_capacity(self, queue_like, task_cycles):
        if task_cycles is None:
            return False
        if getattr(queue_like, "max_load_cycles", None) is not None:
            current_load = queue_like.get_total_load()
            return (current_load + task_cycles) <= queue_like.max_load_cycles
        current_len = queue_like.get_queue_length()
        return current_len < queue_like.max_buffer_size

    def _plan_actions_snapshot(self, actions):
        plans = []
        for i, v in enumerate(self.vehicles):
            act = actions[i]
            plan = {
                "vehicle": v,
                "vehicle_id": v.id,
                "index": i,
                "subtask_idx": None,
                "task_comp": None,
                "task_data": None,
                "desired_target": None,
                "desired_kind": "none",
                "planned_target": None,
                "planned_kind": "none",
                "target_idx": None,
                "illegal_reason": None,
                "power_ratio": None,
                "power_dbm": None,
            }
            if act is None:
                plans.append(plan)
                continue

            # 解析动作：支持字典格式和数组格式
            # - 字典格式: {"target": idx, "power": ratio}
            # - 数组格式: [target_idx, power_level] (MultiDiscrete)
            if isinstance(act, dict):
                target_idx = int(act.get("target", 0))
                p_norm = np.clip(act.get("power", 1.0), 0.0, 1.0)
            else:
                # 数组格式：[target_idx, power_level]
                act_array = np.asarray(act).flatten()
                target_idx = int(act_array[0]) if len(act_array) > 0 else 0
                power_level = int(act_array[1]) if len(act_array) > 1 else 0
                # 将离散等级映射到[0,1]范围
                p_norm = power_level / max(self.config.NUM_POWER_LEVELS - 1, 1)
            
            plan["target_idx"] = target_idx

            subtask_idx = v.task_dag.get_top_priority_task()
            if subtask_idx is None:
                plans.append(plan)
                continue

            task_comp = v.task_dag.total_comp[subtask_idx] if subtask_idx < len(v.task_dag.total_comp) else self.config.MEAN_COMP_LOAD
            task_data = v.task_dag.total_data[subtask_idx] if subtask_idx < len(v.task_dag.total_data) else 0.0
            plan["subtask_idx"] = subtask_idx
            plan["task_comp"] = task_comp
            plan["task_data"] = task_data

            raw_power = self.config.TX_POWER_MIN_DBM + p_norm * (self.config.TX_POWER_MAX_DBM - self.config.TX_POWER_MIN_DBM)
            plan["power_ratio"] = p_norm
            plan["power_dbm"] = np.clip(raw_power, self.config.TX_POWER_MIN_DBM, self.config.TX_POWER_MAX_DBM)

            desired_target = 'Local'
            desired_kind = "local"

            if target_idx >= self.config.MAX_TARGETS:
                plan["illegal_reason"] = "idx_out_of_range"
            elif target_idx == 0:
                desired_target = 'Local'
                desired_kind = "local"
            elif target_idx == 1:
                rsu_id = self._last_rsu_choice.get(v.id)
                if rsu_id is None:
                    plan["illegal_reason"] = "rsu_unavailable"
                    desired_target = 'Local'
                    desired_kind = "local"
                else:
                    rsu = self.rsus[rsu_id] if 0 <= rsu_id < len(self.rsus) else None
                    if rsu is None:
                        plan["illegal_reason"] = "rsu_unavailable"
                        desired_target = 'Local'
                        desired_kind = "local"
                    elif not rsu.is_in_coverage(v.pos):
                        plan["illegal_reason"] = "rsu_out_of_coverage"
                        desired_target = 'Local'
                        desired_kind = "local"
                    else:
                        desired_target = ('RSU', rsu_id)
                        desired_kind = "rsu"
            else:
                candidate_ids = self._last_candidates.get(v.id)
                if candidate_ids is None:
                    plan["illegal_reason"] = "no_candidate_cache"
                    desired_target = 'Local'
                    desired_kind = "local"
                else:
                    neighbor_list_idx = target_idx - 2
                    if 0 <= neighbor_list_idx < len(candidate_ids):
                        neighbor_id = candidate_ids[neighbor_list_idx]
                        if neighbor_id is None or neighbor_id < 0:
                            plan["illegal_reason"] = "id_mapping_fail"
                            desired_target = 'Local'
                            desired_kind = "local"
                        else:
                            target_veh = self._get_vehicle_by_id(neighbor_id)
                            if target_veh is None:
                                plan["illegal_reason"] = "id_mapping_fail"
                                desired_target = 'Local'
                                desired_kind = "local"
                            else:
                                desired_target = int(neighbor_id)
                                desired_kind = "v2v"
                    else:
                        plan["illegal_reason"] = "idx_out_of_range"
                        desired_target = 'Local'
                        desired_kind = "local"

            plan["desired_target"] = desired_target
            plan["desired_kind"] = desired_kind
            plan["planned_target"] = desired_target
            plan["planned_kind"] = desired_kind
            plans.append(plan)

        # RSU conflict resolution (deterministic by vehicle_id)
        rsu_requests = {}
        for plan in plans:
            if plan["subtask_idx"] is None:
                continue
            if plan["illegal_reason"] is not None:
                continue
            if plan["desired_kind"] == "rsu":
                rsu_id = plan["desired_target"][1]
                rsu_requests.setdefault(rsu_id, []).append(plan)

        for rsu_id, reqs in rsu_requests.items():
            if not (0 <= rsu_id < len(self.rsus)):
                for plan in reqs:
                    plan["planned_target"] = 'Local'
                    plan["planned_kind"] = "local"
                    plan["illegal_reason"] = "rsu_unavailable"
                continue
            rsu = self.rsus[rsu_id]
            proc_queues = rsu.queue_manager.processor_queues
            proc_loads = [q.get_total_load() for q in proc_queues]
            proc_limits = [q.max_load_cycles for q in proc_queues]
            proc_sizes = [q.get_queue_length() for q in proc_queues]
            proc_caps = [q.max_buffer_size for q in proc_queues]

            for plan in sorted(reqs, key=lambda p: p["vehicle_id"]):
                chosen_pid = None
                for pid, load in enumerate(proc_loads):
                    if proc_limits[pid] is not None:
                        can_accept = (load + plan["task_comp"]) <= proc_limits[pid]
                    else:
                        can_accept = (proc_sizes[pid] + 1) <= proc_caps[pid]
                    if not can_accept:
                        continue
                    if chosen_pid is None:
                        chosen_pid = pid
                    else:
                        if load < proc_loads[chosen_pid]:
                            chosen_pid = pid
                        elif load == proc_loads[chosen_pid] and pid < chosen_pid:
                            chosen_pid = pid
                if chosen_pid is None:
                    plan["planned_target"] = 'Local'
                    plan["planned_kind"] = "local"
                    plan["illegal_reason"] = "queue_full_conflict"
                else:
                    proc_loads[chosen_pid] += plan["task_comp"]
                    proc_sizes[chosen_pid] += 1

        # V2V conflict resolution (deterministic by vehicle_id)
        v2v_requests = {}
        for plan in plans:
            if plan["subtask_idx"] is None:
                continue
            if plan["illegal_reason"] is not None:
                continue
            if plan["desired_kind"] == "v2v":
                tgt_id = plan["desired_target"]
                v2v_requests.setdefault(tgt_id, []).append(plan)

        for tgt_id, reqs in v2v_requests.items():
            t_veh = self._get_vehicle_by_id(tgt_id)
            if t_veh is None:
                for plan in reqs:
                    plan["planned_target"] = 'Local'
                    plan["planned_kind"] = "local"
                    plan["illegal_reason"] = "id_mapping_fail"
                continue
            queue = t_veh.task_queue
            sim_load = queue.get_total_load()
            sim_len = queue.get_queue_length()
            limit_cycles = queue.max_load_cycles
            limit_size = queue.max_buffer_size

            for plan in sorted(reqs, key=lambda p: p["vehicle_id"]):
                if limit_cycles is not None:
                    can_accept = (sim_load + plan["task_comp"]) <= limit_cycles
                else:
                    can_accept = (sim_len + 1) <= limit_size
                if not can_accept:
                    plan["planned_target"] = 'Local'
                    plan["planned_kind"] = "local"
                    plan["illegal_reason"] = "queue_full_conflict"
                else:
                    sim_load += plan["task_comp"]
                    sim_len += 1

        return plans

    def _init_rsus(self):
        """
        初始化RSU实体列表（道路模型：等间距线性部署）
        
        RSU部署公式：
        - Pos_RSU_j = ((j-1)*D_inter + D_inter/2, Y_RSU)
        - Y_RSU = ROAD_WIDTH + RSU_Y_DIST
        - D_inter = MAP_SIZE / NUM_RSU
        - 断言：NUM_RSU * D_inter >= MAP_SIZE 以确保全覆盖
        """
        num_rsu = getattr(Cfg, 'NUM_RSU', 1)
        self.rsus = []
        
        # 计算道路宽度和RSU Y坐标
        road_width = getattr(Cfg, 'NUM_LANES', 3) * getattr(Cfg, 'LANE_WIDTH', 3.5)
        rsu_y_dist = getattr(Cfg, 'RSU_Y_DIST', 20.0)
        y_rsu = road_width + rsu_y_dist  # RSU的Y坐标（固定值）
        
        # 计算RSU部署间距
        map_size = self.config.MAP_SIZE
        d_inter = map_size / num_rsu  # 等间距部署
        
        # 断言：确保全覆盖
        assert num_rsu * d_inter >= map_size, \
            f"RSU部署间距不足：{num_rsu} * {d_inter} = {num_rsu * d_inter} < {map_size}"
        
        # 验证部署间距满足覆盖约束
        rsu_range = self.config.RSU_RANGE
        max_d_inter = 2 * np.sqrt(rsu_range**2 - y_rsu**2) * 0.9  # 保留10%重叠
        if d_inter > max_d_inter:
            import warnings
            warnings.warn(
                f"RSU部署间距 {d_inter:.2f}m 超过推荐值 {max_d_inter:.2f}m，"
                f"可能导致覆盖盲区。建议增加RSU数量或增大覆盖半径。"
            )
        
        for i in range(num_rsu):
            # RSU位置公式：Pos_RSU_j = ((j-1)*D_inter + D_inter/2, Y_RSU)
            # j从1开始，但索引从0开始，所以j = i+1
            x_pos = (i * d_inter) + (d_inter / 2)
            pos = np.array([x_pos, y_rsu])
            
            rsu = RSU(
                rsu_id=i,
                position=pos,
                cpu_freq=self.config.F_RSU,
                num_processors=getattr(Cfg, 'RSU_NUM_PROCESSORS', 4),
                queue_limit=100,  # 默认队列任务数上限
                coverage_range=rsu_range
            )
            self.rsus.append(rsu)
    
    def _get_nearest_rsu(self, position):
        """
        获取距离指定位置最近的RSU
        
        Args:
            position: 位置坐标 [x, y]
        
        Returns:
            RSU or None: 最近的RSU，如果不在任何RSU覆盖范围内返回None
        """
        if len(self.rsus) == 0:
            return None
        
        nearest_rsu = None
        min_dist = float('inf')
        
        for rsu in self.rsus:
            if rsu.is_in_coverage(position):
                dist = rsu.get_distance(position)
                if dist < min_dist:
                    min_dist = dist
                    nearest_rsu = rsu
        
        return nearest_rsu
    
    def _get_all_rsus_in_range(self, position):
        """
        获取覆盖范围内所有RSU
        
        Args:
            position: 位置坐标 [x, y]
        
        Returns:
            list: 覆盖范围内的RSU列表
        """
        return [rsu for rsu in self.rsus if rsu.is_in_coverage(position)]

    def _select_best_rsu(self, vehicle, task_comp, task_data):
        """
        选择当前车辆的最佳RSU（确定性规则）

        返回:
            tuple: (rsu_id, v2i_rate, wait_time, dist, contact_time)
        """
        if len(self.rsus) == 0:
            return None, 0.0, 0.0, 0.0, 0.0

        best_id = None
        best_rate = 0.0
        best_wait = 0.0
        best_dist = 0.0
        best_contact = 0.0
        best_metric = float('inf')

        speed = np.linalg.norm(vehicle.vel)

        for rsu in self.rsus:
            if not rsu.is_in_coverage(vehicle.pos):
                continue
            if rsu.is_queue_full(new_task_cycles=task_comp):
                continue

            dist = rsu.get_distance(vehicle.pos)
            rate = self.channel.compute_one_rate(
                vehicle, rsu.position, 'V2I', self.time,
                v2i_user_count=self._estimate_v2i_users()
            )
            rate = max(rate, 1e-6)
            tx_time = task_data / rate if task_data > 0 else 0.0
            # [处理器共享] 使用新的延迟估算方法
            wait_time = self._get_node_delay(rsu)
            comp_time = task_comp / max(rsu.cpu_freq, 1e-6)
            metric = tx_time + wait_time + comp_time

            if speed > 0.1:
                contact_time = max(0.0, (rsu.coverage_range - dist) / speed)
            else:
                contact_time = self._max_rsu_contact_time

            if metric < best_metric:
                best_metric = metric
                best_id = rsu.id
                best_rate = rate
                best_wait = wait_time
                best_dist = dist
                best_contact = contact_time

        if best_id is None:
            return None, 0.0, 0.0, 0.0, 0.0

        return best_id, best_rate, best_wait, best_dist, best_contact
    
    def _is_rsu_location(self, loc):
        """
        判断位置标识是否是RSU
        
        Args:
            loc: 位置标识（可能是'RSU'、('RSU', rsu_id)或其他）
        
        Returns:
            bool: 如果是RSU位置返回True
        """
        return loc == 'RSU' or (isinstance(loc, tuple) and loc[0] == 'RSU')
    
    def _get_rsu_id_from_location(self, loc):
        """
        从位置标识中提取RSU ID
        
        Args:
            loc: 位置标识
        
        Returns:
            int or None: RSU ID，如果不是RSU则返回None
        """
        if loc == 'RSU':
            # 兼容旧代码：单个RSU场景，返回第一个RSU的ID
            return 0 if len(self.rsus) > 0 else None
        elif isinstance(loc, tuple) and loc[0] == 'RSU':
            return loc[1]
        return None
    
    def _get_rsu_position(self, rsu_id):
        """
        获取RSU的位置
        
        Args:
            rsu_id: RSU ID
        
        Returns:
            np.array or None: RSU位置，如果ID无效返回None
        """
        if 0 <= rsu_id < len(self.rsus):
            return self.rsus[rsu_id].position
        return None

    def _get_vehicle_by_id(self, veh_id):
        """
        根据车辆ID获取车辆对象

        Args:
            veh_id: 车辆ID

        Returns:
            Vehicle or None
        """
        for veh in self.vehicles:
            if veh.id == veh_id:
                return veh
        return None
    
    def _get_total_W_remaining(self):
        """
        [P2辅助函数] 计算所有DAG的总剩余计算量（cycles）
        
        Returns:
            float: 总剩余计算量（cycles）
        """
        total_W = 0.0
        for v in self.vehicles:
            dag = v.task_dag
            # 从active_task_manager获取活跃任务的剩余计算量
            if hasattr(v, 'active_task_manager'):
                for task in v.active_task_manager.active_tasks:
                    total_W += task.rem_comp
            
            # 从task_dag获取未完成subtask的剩余计算量
            for i in range(dag.num_subtasks):
                if dag.status[i] < 3:  # 未完成
                    # 优先从active_task_manager获取
                    task_in_active = None
                    if hasattr(v, 'active_task_manager'):
                        task_in_active = v.active_task_manager.get_task(v.id, i)
                    
                    if task_in_active:
                        total_W += task_in_active.rem_comp
                    else:
                        total_W += dag.total_comp[i]
        
        return total_W
    
    def _get_total_active_tasks(self):
        """
        [P2辅助函数] 计算所有节点（车辆+RSU）的活跃任务总数
        
        Returns:
            int: 总活跃任务数
        """
        total_active = 0
        # 车辆活跃任务
        for v in self.vehicles:
            if hasattr(v, 'active_task_manager'):
                total_active += v.active_task_manager.get_num_active_tasks()
        
        # RSU活跃任务
        for rsu in self.rsus:
            if hasattr(rsu, 'active_task_manager'):
                total_active += rsu.active_task_manager.get_num_active_tasks()
        
        return total_active
    
    def _handle_task_completion(self, task, compute_node):
        """
        处理任务完成事件（新物理引擎回调）
        
        连接物理层（ActiveTaskManager）与逻辑层（DAG状态）
        
        Args:
            task: 完成的ActiveTask对象
            compute_node: 执行节点（Vehicle或RSU）
        """
        # 找到任务所属车辆
        owner_vehicle = self._get_vehicle_by_id(task.owner_id)
        if owner_vehicle is None:
            # 车辆可能已离开场景
            return
        
        # [新增] 记录真实任务完成时间（物理指标）
        # task_duration = 完成时间 - 开始时间
        task_duration = self.time - task.assigned_time
        if task_duration > 0:  # 确保是有效的时间
            self._episode_task_durations.append(task_duration)
        
        # 更新DAG状态：标记子任务完成
        subtask_id = task.subtask_id
        dag = owner_vehicle.task_dag
        
        # [硬断言] 边界检查
        assert subtask_id >= 0 and subtask_id < len(dag.status), (
            f"❌ _handle_task_completion边界错误: owner={task.owner_id}, "
            f"subtask={subtask_id}, dag.num_subtasks={len(dag.status)}"
        )
        
        # [硬断言] 记录完成前的状态和计数
        before_completed = int(np.sum(dag.status == 3))
        before_status = int(dag.status[subtask_id])
        
        # [关键修复] 在调用_mark_done前，设置task_locations以支持同节点传输判断
        # 确保_mark_done能正确判断是否需要创建传输任务
        if subtask_id < len(dag.task_locations):
            if dag.task_locations[subtask_id] is None:
                # 根据执行节点推断location
                if task.task_type == 'local':
                    dag.task_locations[subtask_id] = 'Local'
                elif task.task_type == 'v2i':
                    # 如果是RSU执行，找到RSU的ID
                    if isinstance(compute_node, RSU):
                        for rsu_idx, rsu in enumerate(self.rsus):
                            if rsu is compute_node:
                                dag.task_locations[subtask_id] = ('RSU', rsu_idx)
                                break
                elif task.task_type == 'v2v':
                    # 如果是V2V接收车辆执行，location是接收车辆ID
                    if hasattr(compute_node, 'id'):
                        dag.task_locations[subtask_id] = compute_node.id
        
        # 调用_mark_done，它应该返回解锁的READY节点数
        unlocked_ready_count = dag._mark_done(subtask_id)
        
        # [硬断言] 完成计数+1
        after_completed = int(np.sum(dag.status == 3))
        assert after_completed == before_completed + 1, (
            f"❌ _handle_task_completion完成计数错误: owner={task.owner_id}, "
            f"subtask={subtask_id}, before={before_completed}, after={after_completed}, "
            f"期望after=before+1"
        )
        
        # [硬断言] 状态转换正确
        assert dag.status[subtask_id] == 3, (
            f"❌ _handle_task_completion状态转换错误: owner={task.owner_id}, "
            f"subtask={subtask_id}, before_status={before_status}, "
            f"after_status={dag.status[subtask_id]}, 期望COMPLETED(3)"
        )
        
        # [诊断] 记录解锁信息（用于死锁诊断）
        if not hasattr(dag, '_unlocked_ready_history'):
            dag._unlocked_ready_history = []
        dag._unlocked_ready_history.append({
            'subtask_id': subtask_id,
            'unlocked_count': unlocked_ready_count,
            'time': self.time
        })
            
        # [审计] V2V生命周期: dag_completed
        if task.task_type == 'v2v':
            self._audit_record_v2v_lifecycle('dag_completed', task.owner_id, subtask_id)
            self._audit_check_task_state_conflict(task.owner_id, subtask_id, 'COMPLETED', None)
        
        # 从计算节点的Active中移除（已由step()自动完成）
        # 从旧队列中移除（向后兼容）
        if hasattr(compute_node, 'task_queue'):
            if compute_node.task_queue.get_queue_length() > 0:
                compute_node.task_queue.dequeue_one()
            if hasattr(compute_node, 'update_queue_sync'):
                compute_node.update_queue_sync()

    def _update_rate_norm(self, rate, link_type):
        # 归一化模式已固化为static，此方法保留以兼容接口调用
        # Normalization mode is fixed to static; method kept for interface compatibility
        pass

    def _get_norm_rate(self, link_type):
        # 归一化模式已固化为static，直接返回静态常量
        # Normalization mode fixed to static; directly return static constants
        return self.config.NORM_MAX_RATE_V2I if link_type == 'V2I' else self.config.NORM_MAX_RATE_V2V

    def _power_ratio_from_dbm(self, power_dbm):
        p_min = getattr(Cfg, "TX_POWER_MIN_DBM", power_dbm)
        p_max = getattr(Cfg, "TX_POWER_MAX_DBM", p_min)
        denom = p_max - p_min
        if denom <= 0:
            return 0.0
        return float(np.clip((power_dbm - p_min) / denom, 0.0, 1.0))

    def _get_p_max_watt(self, target):
        if target == 'Local':
            return 0.0
        if self._is_rsu_location(target):
            p_dbm = getattr(Cfg, "TX_POWER_UP_DBM", getattr(Cfg, "TX_POWER_MAX_DBM", getattr(Cfg, "TX_POWER_MIN_DBM", 20.0)))
        elif isinstance(target, int):
            p_dbm = getattr(Cfg, "TX_POWER_V2V_DBM", getattr(Cfg, "TX_POWER_MAX_DBM", getattr(Cfg, "TX_POWER_MIN_DBM", 20.0)))
        else:
            p_dbm = getattr(Cfg, "TX_POWER_MAX_DBM", getattr(Cfg, "TX_POWER_MIN_DBM", 20.0))
        return self.config.dbm2watt(p_dbm)

    def _build_task_locations_pi0(self, vehicle):
        num_tasks = vehicle.task_dag.num_subtasks
        task_locations = ['Local'] * num_tasks
        if hasattr(vehicle, 'exec_locations'):
            for i in range(num_tasks):
                if vehicle.task_dag.exec_locations[i] is not None:
                    task_locations[i] = vehicle.task_dag.exec_locations[i]
        if hasattr(vehicle.task_dag, 'task_locations'):
            for i in range(num_tasks):
                if task_locations[i] == 'Local' and vehicle.task_dag.task_locations[i] is not None:
                    task_locations[i] = vehicle.task_dag.task_locations[i]
        if vehicle.curr_subtask is not None and 0 <= vehicle.curr_subtask < num_tasks:
            task_locations[vehicle.curr_subtask] = vehicle.curr_target
        return task_locations

    def _compute_mean_cft_pi0(self, snapshot_time=None, v2i_user_count=None, vehicle_ids=None):
        if snapshot_time is None:
            snapshot_time = self.time
        if v2i_user_count is None:
            v2i_user_count = self._estimate_v2i_users()
        cft_list = []
        vehicles = self.vehicles
        if vehicle_ids is not None:
            vehicles = [self._get_vehicle_by_id(vid) for vid in vehicle_ids]
        for v in vehicles:
            if v is None:
                continue
            if v.task_dag.is_finished:
                cft_list.append(snapshot_time)
                continue
            task_locations = self._build_task_locations_pi0(v)
            try:
                from envs.modules.time_calculator import calculate_est_ct
                _, _, cft = calculate_est_ct(
                    v, v.task_dag, task_locations,
                    self.channel, self.rsus, self.vehicles, snapshot_time,
                    v2i_user_count=v2i_user_count
                )
                cft_list.append(cft)
            except Exception:
                cft_list.append(snapshot_time + 100.0)
        if not cft_list:
            return snapshot_time
        return float(np.mean(cft_list))

    def _compute_vehicle_cfts_snapshot(self, snapshot_time, vehicle_ids=None):
        vehicle_cfts = []
        vehicles = self.vehicles
        if vehicle_ids is not None:
            vehicles = [self._get_vehicle_by_id(vid) for vid in vehicle_ids]
        for v in vehicles:
            if v is None:
                vehicle_cfts.append(np.nan)
                continue
            if v.task_dag.is_finished:
                vehicle_cfts.append(snapshot_time)
                continue
            task_locations = self._build_task_locations_pi0(v)
            try:
                from envs.modules.time_calculator import calculate_est_ct
                _, _, cft = calculate_est_ct(
                    v,
                    v.task_dag,
                    task_locations,
                    self.channel,
                    self.rsus,
                    self.vehicles,
                    snapshot_time,
                    v2i_user_count=self._estimate_v2i_users(),
                )
                vehicle_cfts.append(cft)
            except Exception:
                vehicle_cfts.append(np.nan)
        return vehicle_cfts

    def reset(self, seed=None, options=None):
        if seed is not None:
            np.random.seed(seed)

        self.vehicles = []
        self.time = 0.0
        self.steps = 0
        self._episode_steps = 0
        # [P2性能统计] Episode级统计清零
        self._p2_active_time = 0.0
        self._p2_idle_time = 0.0
        self._p2_deltaW_active = 0.0
        self._p2_zero_delta_steps = 0
        
        # =====================================================================
        # [FIFO队列系统] 清空所有队列与账本（防止跨episode污染）
        # =====================================================================
        self.txq_v2i = defaultdict(deque)
        self.txq_v2v = defaultdict(deque)
        self.veh_cpu_q = defaultdict(deque)
        self.rsu_cpu_q = defaultdict(lambda: defaultdict(deque))
        self.active_edge_keys = set()
        
        # FIFO能耗账本
        self.E_tx_input_cost = defaultdict(float)
        self.E_tx_edge_record = defaultdict(float)
        self.E_cpu_local_cost = defaultdict(float)
        self.CPU_cycles_local = defaultdict(float)
        self.CPU_cycles_rsu_record = defaultdict(float)
        # 重置RSU队列和FAT
        for rsu in self.rsus:
            rsu.clear_queue()
            rsu.reset_fat()
        if abs(self.time - self._cft_cache_time) > self.config.DT * 0.5:
            self._cft_cache = None
            self._cft_cache_valid = False

        for i in range(self.config.NUM_VEHICLES):
            # 车辆初始位置：在前30%道路上随机分布
            # X坐标：随机在[0, 0.3*MAP_SIZE]范围内
            # Y坐标：随机选择车道中心（道路模型：3条车道）
            x_pos = np.random.uniform(0, 0.3 * self.config.MAP_SIZE)
            lane_centers = [(k + 0.5) * self.config.LANE_WIDTH for k in range(self.config.NUM_LANES)]
            y_pos = np.random.choice(lane_centers)
            pos = np.array([x_pos, y_pos])
            
            v = Vehicle(i, pos)
            v.cpu_freq = np.random.uniform(self.config.MIN_VEHICLE_CPU_FREQ, self.config.MAX_VEHICLE_CPU_FREQ)
            v.tx_power_dbm = self.config.TX_POWER_DEFAULT_DBM if hasattr(Cfg, 'TX_POWER_DEFAULT_DBM') else self.config.TX_POWER_MIN_DBM

            n_node = np.random.randint(self.config.MIN_NODES, self.config.MAX_NODES + 1)
            adj, prof, data, ddl, extra = self.dag_gen.generate(n_node, veh_f=v.cpu_freq)
            v.task_dag = DAGTask(0, adj, prof, data, ddl)
            v.task_dag.deadline_gamma = extra.get("deadline_gamma")
            v.task_dag.critical_path_cycles = extra.get("critical_path_cycles")
            v.task_dag.deadline_base_time = extra.get("deadline_base_time")
            v.task_dag.deadline_slack = extra.get("deadline_slack")
            v.task_dag.start_time = 0.0
            v.task_queue.clear()  # 清空队列
            v.task_queue_len = 0  # 同步队列长度
            
            # 道路模型：速度已在Vehicle.__init__中设置（截断正态分布，沿X轴正方向）
            # 这里不需要重新设置速度，Vehicle类会自动处理
            
            v.last_scheduled_subtask = -1
            v.last_action_step = -1
            v.last_action_target = 'Local'
            v.subtask_reward_buffer = 0.0
            # exec_locations应该引用task_dag的，而不是创建新列表
            # v.exec_locations = [None] * v.task_dag.num_subtasks  # 错误：创建了新对象
            # 正确做法：不需要设置，直接使用v.task_dag.exec_locations

            self.vehicles.append(v)
            self._vehicles_seen.add(v.id)
        
        # 道路模型：初始化动态车辆生成的下一辆到达时间（泊松过程）
        # 如果VEHICLE_ARRIVAL_RATE > 0，则启用动态生成
        if hasattr(Cfg, 'VEHICLE_ARRIVAL_RATE') and self.config.VEHICLE_ARRIVAL_RATE > 0:
            # 下一辆车的到达时间间隔服从指数分布：Δt ~ Exponential(λ)
            # 初始下一辆到达时间：从当前时间开始的第一个到达时间
            self._next_vehicle_arrival_time = np.random.exponential(1.0 / self.config.VEHICLE_ARRIVAL_RATE)
            self._next_vehicle_id = self.config.NUM_VEHICLES  # 车辆ID从初始数量开始
        else:
            self._next_vehicle_arrival_time = float('inf')  # 禁用动态生成
            self._next_vehicle_id = self.config.NUM_VEHICLES

        self.last_global_cft = self._calculate_global_cft_critical_path()
        # [P2性能统计] 初始化W_prev（在车辆生成后）
        self._p2_W_prev = self._get_total_W_remaining()
        
        # [Episode统计] 初始化episode级统计
        self._last_episode_metrics = {}
        self._decision_counts = {'local': 0, 'rsu': 0, 'v2v': 0}
        
        return self._get_obs(), {}

    # =====================================================================
    # [FIFO队列系统] Phase 1-5 推进方法
    # =====================================================================
    
    def _try_enqueue_compute_if_ready(self, vehicle, subtask_id):
        """
        [兼容层] 委托到DAG完成处理器
        
        保留此方法以保持向后兼容，实际逻辑已迁移到DagCompletionHandler。
        """
        result = self._dag_handler._try_enqueue_compute_if_ready(
            vehicle, subtask_id, self.time, self.veh_cpu_q, self.rsu_cpu_q, self.rsus
        )
        return result is not None
    
    def _phase1_commit_decisions(self, commit_plans):
        """
        [Phase1: Commit决策]
        
        职责：
        1. 写入exec_locations（权威事实源，表示"位置已确定"）
        2. 若target==Local：INPUT不入队列，标记input_ready，尝试入计算队列
        3. 若target!=Local：创建INPUT TransferJob并入对应通信队列
        
        硬断言：
        - Local目标不得创建INPUT TransferJob
        - exec_locations一旦写入不可改（由assign_task保证）
        """
        for plan in commit_plans:
            v = plan["vehicle"]
            subtask_idx = plan["subtask_idx"]
            actual_target = plan["planned_target"] if plan["planned_target"] is not None else 'Local'
            
            if subtask_idx is None or subtask_idx < 0:
                continue

            # [Phase1职责] 写入exec_locations（由assign_task执行）
            assign_success = v.task_dag.assign_task(subtask_idx, actual_target)
            if not assign_success:
                v.illegal_action = True
                v.illegal_reason = "assign_failed"
                continue
            
            # 统计决策类型（已移除，使用StatsCollector）
            
            # [INPUT传输逻辑]
            task_data = v.task_dag.total_data[subtask_idx]
            
            if actual_target == 'Local':
                # [Local路径] INPUT不入队列，视为input_ready（数据本地已存在）
                v.task_dag.rem_data[subtask_idx] = 0.0
                # 标记input_ready（可选字段，如果DAG支持）
                if hasattr(v.task_dag, 'input_ready'):
                    v.task_dag.input_ready[subtask_idx] = True
                
                # [Local路径] 立即尝试入计算队列（使用handler）
                self._dag_handler._try_enqueue_compute_if_ready(
                    v, subtask_idx, self.time, self.veh_cpu_q, self.rsu_cpu_q, self.rsus
                )
            
            else:
                # [卸载路径] 创建INPUT TransferJob
                # 确定src/dst节点
                src_node = ("VEH", v.id)
                if isinstance(actual_target, tuple) and actual_target[0] == 'RSU':
                    dst_node = ("RSU", actual_target[1])
                    link_type = "V2I"
                elif isinstance(actual_target, int):
                    dst_node = ("VEH", actual_target)
                    # 判断link_type（V2I or V2V）
                    link_type = "V2V"
                else:
                    # 异常情况，fallback到Local
                    v.illegal_action = True
                    v.illegal_reason = "invalid_target"
                    continue
                
                # 创建TransferJob
                job = TransferJob(
                    kind="INPUT",
                    src_node=src_node,
                    dst_node=dst_node,
                    owner_vehicle_id=v.id,
                    subtask_id=subtask_idx,
                    rem_bytes=task_data,
                    tx_power_dbm=v.tx_power_dbm,  # INPUT使用动作映射功率
                    link_type=link_type,
                    enqueue_time=self.time,
                    parent_task_id=None  # INPUT无parent
                )
                
                # 入队到对应通信队列
                if link_type == "V2I":
                    if src_node not in self.txq_v2i:
                        self.txq_v2i[src_node] = deque()
                    self.txq_v2i[src_node].append(job)
                else:  # V2V
                    if src_node not in self.txq_v2v:
                        self.txq_v2v[src_node] = deque()
                    self.txq_v2v[src_node].append(job)
    
    def _phase2_activate_edge_transfers(self):
        """
        [Phase2: 激活待传依赖边]
        
        职责：
        扫描每个DAG的inter_task_transfers，对于child_exec_loc已确定的边：
        1. 若parent_loc == child_loc：瞬时清零rem_bytes，不入队列
        2. 若parent_loc != child_loc：创建EDGE TransferJob（固定最大功率）
        
        硬断言：
        - child_exec_loc未确定（None）=> continue（绝对不创建/不推进/不清零）
        - 同位置EDGE不得入队列
        - EDGE唯一键不得重复（去重）
        """
        for v in self.vehicles:
            dag = v.task_dag
            if not hasattr(dag, 'inter_task_transfers'):
                continue
            
            # 扫描所有待传边
            for child_id, parents_dict in list(dag.inter_task_transfers.items()):
                # 获取child执行位置（必须已确定）
                child_exec_loc = v.exec_locations[child_id] if child_id < len(v.exec_locations) else None
                
                if child_exec_loc is None:
                    # [硬断言护栏] child未分配，绝不创建/推进/清零
                    continue
                
                # 扫描该child的所有parent边
                for parent_id, transfer_info in list(parents_dict.items()):
                    if transfer_info['rem_bytes'] <= 0:
                        continue  # 已完成
                    
                    # 获取parent完成位置
                    parent_task_loc = dag.task_locations[parent_id] if parent_id < len(dag.task_locations) else None
                    
                    if parent_task_loc is None:
                        # parent未完成，暂不处理（等待parent完成）
                        continue
                    
                    # [关键判断] 是否同位置
                    same_location = (parent_task_loc == child_exec_loc)
                    
                    if same_location:
                        # [同位置] 瞬时到齐，不入队列
                        transfer_info['rem_bytes'] = 0.0
                        # 调用DAG的边到齐函数（触发edge_ready检查）
                        dag.step_inter_task_transfers(child_id, 0.0, 0.0)
                    else:
                        # [不同位置] 创建EDGE TransferJob（固定最大功率）
                        
                        # [EDGE去重] 检查唯一键
                        edge_key = (v.id, child_id, parent_id)
                        if edge_key in self.active_edge_keys:
                            # 已存在，跳过（防止重复创建）
                            continue
                        
                        # 确定src/dst节点
                        def location_to_node(loc):
                            if loc == 'Local':
                                return ("VEH", v.id)
                            elif isinstance(loc, tuple) and loc[0] == 'RSU':
                                return ("RSU", loc[1])
                            elif isinstance(loc, int):
                                return ("VEH", loc)
                            else:
                                return None
                        
                        src_node = location_to_node(parent_task_loc)
                        dst_node = location_to_node(child_exec_loc)
                        
                        if src_node is None or dst_node is None:
                            continue  # 异常，跳过
                        
                        # 判断link_type
                        if src_node[0] == "RSU" or dst_node[0] == "RSU":
                            link_type = "V2I"
                        else:
                            link_type = "V2V"
                        
                        # 创建EDGE TransferJob（固定最大功率）
                        job = TransferJob(
                            kind="EDGE",
                            src_node=src_node,
                            dst_node=dst_node,
                            owner_vehicle_id=v.id,
                            subtask_id=child_id,
                            rem_bytes=transfer_info['rem_bytes'],
                            tx_power_dbm=self.config.TX_POWER_MAX_DBM,  # EDGE固定最大功率
                            link_type=link_type,
                            enqueue_time=self.time,
                            parent_task_id=parent_id
                        )
                        
                        # 入队到对应通信队列
                        if link_type == "V2I":
                            if src_node not in self.txq_v2i:
                                self.txq_v2i[src_node] = deque()
                            self.txq_v2i[src_node].append(job)
                        else:  # V2V
                            if src_node not in self.txq_v2v:
                                self.txq_v2v[src_node] = deque()
                            self.txq_v2v[src_node].append(job)
                        
                        # 标记已激活（防止重复）
                        self.active_edge_keys.add(edge_key)
    
    def _phase3_serve_communication_queues(self):
        """
        [Phase3: 推进通信队列]
        
        职责：
        对每个tx_node，并行推进txq_v2i和txq_v2v两条队列：
        1. 每条队列独立拥有DT时间预算
        2. FIFO串行：队头未完成，后续不推进
        3. work-conserving：队头完成后用剩余时间推进下一个
        4. 传输完成后调用finalize_transfer（INPUT入计算队列，EDGE清零）
        
        能耗记账（严格口径）：
        - INPUT发射能耗 => E_tx_input_cost[u]（纳入成本）
        - EDGE发射能耗 => E_tx_edge_record[u]（仅记录）
        """
        # 每步清零队列中job的step级统计，确保时间预算按步计算
        for q_dict in (self.txq_v2i, self.txq_v2v):
            for q in q_dict.values():
                for job in q:
                    job.step_time_used = 0.0
                    job.step_bytes_sent = 0.0
        # 合并所有tx_node并通过服务推进
        comm_result = self._comm_service.step(
            self.txq_v2i,
            self.txq_v2v,
            self.config.DT,
            self.time,
            rate_fn=lambda job, tx_node: self._compute_job_rate(job, tx_node),
        )
        
        # 应用结果：能耗账本与完成回调
        for veh_id, delta in comm_result.energy_delta_cost.items():
            self.E_tx_input_cost[veh_id] = self.E_tx_input_cost.get(veh_id, 0.0) + delta
        for veh_id, delta in comm_result.energy_delta_record_edge.items():
            self.E_tx_edge_record[veh_id] = self.E_tx_edge_record.get(veh_id, 0.0) + delta
        # 使用DAG完成处理器处理传输完成
        for job in comm_result.completed_jobs:
            v = self._get_vehicle_by_id(job.owner_vehicle_id)
            if v is not None:
                self._dag_handler.on_transfer_done(
                    job, v, self.time, self.active_edge_keys,
                    self.veh_cpu_q, self.rsu_cpu_q, self.rsus
                )
    
    def _compute_job_rate(self, job, tx_node):
        """
        计算TransferJob的传输速率
        
        注意：
        - INPUT：使用job.tx_power_dbm（来自动作）
        - EDGE：使用job.tx_power_dbm=MAX（固定最大功率）
        - 通过power_dbm_override参数传递给channel
        """
        # 获取src和dst位置
        if tx_node[0] == "VEH":
            src_veh = self._get_vehicle_by_id(tx_node[1])
            if src_veh is None:
                return 0.0
            src_pos = src_veh.pos
        else:  # RSU
            rsu_id = tx_node[1]
            if 0 <= rsu_id < len(self.rsus):
                src_pos = self.rsus[rsu_id].position
            else:
                return 0.0
        
        if job.dst_node[0] == "VEH":
            dst_veh = self._get_vehicle_by_id(job.dst_node[1])
            if dst_veh is None:
                return 0.0
            dst_pos = dst_veh.pos
        else:  # RSU
            rsu_id = job.dst_node[1]
            if 0 <= rsu_id < len(self.rsus):
                dst_pos = self.rsus[rsu_id].position
            else:
                return 0.0
        
        # 计算速率
        # 注意：power_dbm_override允许覆盖功率（EDGE用）
        if tx_node[0] == "VEH":
            # 车辆作为发送端
            vehicle = src_veh
            rate = self.channel.compute_one_rate(
                vehicle, dst_pos, job.link_type, self.time,
                power_dbm_override=job.tx_power_dbm  # 显式传递功率
            )
        else:
            # RSU作为发送端（下行）
            # 使用channel的V2I速率计算，但需要构造proxy vehicle对象
            # 创建临时vehicle对象代表RSU的发送能力
            class RSUProxy:
                def __init__(self, position, tx_power_dbm):
                    self.pos = position
                    self.tx_power_dbm = tx_power_dbm
            
            rsu_proxy = RSUProxy(src_pos, job.tx_power_dbm)
            rate = self.channel.compute_one_rate(
                rsu_proxy, dst_pos, "V2I", self.time,
                power_dbm_override=job.tx_power_dbm
            )
        
        return rate
    
    def _finalize_transfer(self, job):
        """
        [兼容层] 委托到DAG完成处理器
        
        保留此方法以保持向后兼容，实际逻辑已迁移到DagCompletionHandler.on_transfer_done()。
        
        INPUT完成：
        1. 回写rem_data=0
        2. 若edge_ready，创建ComputeJob并入计算队列（时隙内联动）
        
        EDGE完成：
        1. 回写inter_task_transfers[child][parent].rem_bytes=0
        2. 调用DAG.step_inter_task_transfers触发edge_ready检查
        3. 清除active_edge_key
        """
        v = self._get_vehicle_by_id(job.owner_vehicle_id)
        if v is not None:
            self._dag_handler.on_transfer_done(
                job, v, self.time, self.active_edge_keys,
                self.veh_cpu_q, self.rsu_cpu_q, self.rsus
            )
    
    def _phase4_serve_compute_queues(self):
        """
        [Phase4: 推进计算队列]
        
        职责：
        对每个处理器队列并行推进：
        1. FIFO串行：队头未完成，后续不推进
        2. work-conserving：队头完成后用剩余时间推进下一个
        3. 计算完成后调用finalize_compute（写task_locations，调用_mark_done）
        
        能耗记账（严格口径）：
        - 本地计算能耗 => E_cpu_local_cost[u]（纳入成本）
        - RSU计算：只记录cycles，不计入成本
        """
        # 通过服务推进所有计算队列，收集结果
        cpu_result = self._cpu_service.step(
            self.veh_cpu_q,
            self.rsu_cpu_q,
            self.config.DT,
            self.time,
            veh_cpu_hz_fn=lambda vid: getattr(self._get_vehicle_by_id(vid), "cpu_freq", self.config.MIN_VEHICLE_CPU_FREQ),
            rsu_cpu_hz_fn=lambda rid: self.rsus[rid].cpu_freq if 0 <= rid < len(self.rsus) else self.config.F_RSU,
        )

        # 统一应用结果
        for veh_id, delta in cpu_result.energy_delta_cost_local.items():
            self.E_cpu_local_cost[veh_id] = self.E_cpu_local_cost.get(veh_id, 0.0) + delta
        for veh_id, cycles in cpu_result.cycles_done_local.items():
            self.CPU_cycles_local[veh_id] = self.CPU_cycles_local.get(veh_id, 0.0) + cycles
        for rsu_id, cycles in cpu_result.cycles_done_rsu_record.items():
            self.CPU_cycles_rsu_record[rsu_id] = self.CPU_cycles_rsu_record.get(rsu_id, 0.0) + cycles
        # 使用DAG完成处理器处理计算完成
        for job in cpu_result.completed_jobs:
            v = self._get_vehicle_by_id(job.owner_vehicle_id)
            if v is not None:
                self._dag_handler.on_compute_done(job, v, self.time)
    
    # 兼容旧调用：委托到 cpu_service，用于测试/内部调用
    def _finalize_compute(self, job):
        """
        [兼容层] 委托到DAG完成处理器
        
        保留此方法以保持向后兼容，实际逻辑已迁移到DagCompletionHandler.on_compute_done()。
        
        【重要】位置编码一致性：
        - exec_locations 和 task_locations 都使用位置码：'Local' | ('RSU',id) | int(veh_id)
        - job.exec_node 是 node tuple: ("VEH",i) | ("RSU",j)，仅用于队列key
        - 必须从 exec_locations 读取位置码写入 task_locations
        """
        v = self._get_vehicle_by_id(job.owner_vehicle_id)
        if v is not None:
            self._dag_handler.on_compute_done(job, v, self.time)
    
    # =====================================================================
    # [主step方法] 调用5个Phase
    # =====================================================================
    
    def step(self, actions):
        self.steps += 1
        self._episode_steps += 1
        
        # 初始化决策统计（如果不存在）
        if not hasattr(self, '_decision_counts'):
            self._decision_counts = {'local': 0, 'rsu': 0, 'v2v': 0}


        snapshot_time = self.time  # 奖励时间轴：步前时间

        if abs(self.time - self._cache_time_step) > 1e-6:
            self._comm_rate_cache.clear()
            self._cache_time_step = self.time

        self._cft_cache = None
        self._cft_cache_valid = False
        self._dist_matrix_cache = None
        self._rsu_dist_cache.clear()

        ids_prev = [v.id for v in self.vehicles]
        v2i_users_prev = self._estimate_v2i_users()
        t_prev = snapshot_time
        cft_prev_abs = self._compute_mean_cft_pi0(
            snapshot_time=t_prev,
            v2i_user_count=v2i_users_prev,
            vehicle_ids=ids_prev
        )
        cft_prev_rem = max(cft_prev_abs - t_prev, 0.0) if cft_prev_abs is not None else 0.0
        if not np.isfinite(cft_prev_rem):
            cft_prev_rem = 0.0

        step_congestion_cost = 0.0
        active_agents_count = 0

        for v in self.vehicles:
            v.illegal_action = False
            v.illegal_reason = None
        step_tx_time = {v.id: 0.0 for v in self.vehicles}
        step_power_ratio = {
            v.id: self._power_ratio_from_dbm(getattr(v, "tx_power_dbm", getattr(Cfg, "TX_POWER_MIN_DBM", 0.0)))
            for v in self.vehicles
        }

        # =====================================================================
        # [新FIFO队列系统] Phase 1-5 推进
        # =====================================================================
        
        # 解析动作并生成计划
        plans = self._plan_actions_snapshot(actions)
        commit_plans = [p for p in plans if p["subtask_idx"] is not None]
        commit_plans.sort(key=lambda p: p["vehicle_id"])
        
        # 更新功率（在Phase1之前）
        for plan in commit_plans:
            v = plan["vehicle"]
            if plan["power_dbm"] is not None:
                v.tx_power_dbm = plan["power_dbm"]
                step_power_ratio[v.id] = plan["power_ratio"] if plan["power_ratio"] is not None else step_power_ratio.get(v.id, 0.0)
            
            if plan["illegal_reason"] is not None:
                v.illegal_action = True
                v.illegal_reason = plan["illegal_reason"]
            else:
                v.illegal_action = False
                v.illegal_reason = None
            
            # 统计决策分布
            target = plan.get("planned_target", 'Local')
            if target == 'Local' or target == 0:
                self._decision_counts['local'] += 1
            elif target == 'RSU' or target == 1:
                self._decision_counts['rsu'] += 1
            else:
                self._decision_counts['v2v'] += 1
        
        # Phase 1: Commit决策（写入exec_locations + 创建INPUT队列）
        self._phase1_commit_decisions(commit_plans)
        
        # Phase 2: 激活EDGE传输（禁止child_loc None fallback）
        self._phase2_activate_edge_transfers()
        
        # Phase 3: 推进通信队列（并行FIFO + work-conserving）
        self._phase3_serve_communication_queues()
        
        # Phase 4: 推进计算队列（并行FIFO + work-conserving）
        self._phase4_serve_compute_queues()
        
        # =====================================================================
        # [时间轴推进] 完成本步所有FIFO推进后，全局时间前进DT
        # =====================================================================
        self.time += self.config.DT
        
        # =====================================================================
        # [车辆移动与动态管理]
        # =====================================================================
        for v in self.vehicles:
            # 更新车辆位置（道路模型：一维移动）
            v.update_pos(self.config.DT, self.config.MAP_SIZE)
        
        # 移除超出边界的车辆（道路模型：车辆超出道路长度L后移除）
        vehicles_to_remove = []

        rewards = []
        vehicle_cfts = self._compute_vehicle_cfts_snapshot(self.time)
        
        # 保存每个车辆的CFT（用于观测和奖励计算）
        self.vehicle_cfts = vehicle_cfts
        # 全局CFT使用所有车辆的最大值（用于兼容旧代码）
        self.last_global_cft = np.nanmax(vehicle_cfts) if len(vehicle_cfts) > 0 and np.any(np.isfinite(vehicle_cfts)) else np.nan
        v2i_users_curr = self._estimate_v2i_users()
        t_curr = self.time
        cft_curr_abs = self._compute_mean_cft_pi0(
            snapshot_time=t_curr,
            v2i_user_count=v2i_users_curr,
            vehicle_ids=ids_prev
        )
        cft_curr_rem = max(cft_curr_abs - t_curr, 0.0) if cft_curr_abs is not None else 0.0
        if not np.isfinite(cft_curr_rem):
            cft_curr_rem = 0.0
        cft_prev_rem = max(cft_prev_rem, 0.0)
        cft_curr_rem = max(cft_curr_rem, 0.0)
        dCFT_abs = float(cft_prev_abs - cft_curr_abs) if (cft_prev_abs is not None and cft_curr_abs is not None) else 0.0
        dT_rem = cft_prev_rem - cft_curr_rem
        dT = float(np.clip(dT_rem, self.config.DELTA_CFT_CLIP_MIN, self.config.DELTA_CFT_CLIP_MAX))
        dT_eff = dT - self.config.DT
        
        # 计算奖励
        for i, v in enumerate(self.vehicles):
            dag = v.task_dag
            target = v.curr_target if v.curr_subtask is not None else None
            task_idx = v.curr_subtask if v.curr_subtask is not None else None
            if task_idx is None and getattr(v, 'last_action_step', -1) == self.steps:
                pass  # 已清理
                last_idx = getattr(v, 'last_scheduled_subtask', -1)
                if 0 <= last_idx < dag.num_subtasks:
                    task_idx = last_idx
                    target = v.last_action_target
            if target is None:
                target = 'Local'
            data_size = dag.total_data[task_idx] if task_idx is not None and task_idx < len(dag.total_data) else 0.0

            # 获取任务计算量（用于基于计算量的队列限制检查）
            task_comp = dag.total_comp[task_idx] if task_idx is not None and task_idx < len(dag.total_comp) else self.config.MEAN_COMP_LOAD
            power_ratio = float(np.clip(step_power_ratio.get(v.id, 0.0), 0.0, 1.0))
            t_tx_raw = float(step_tx_time.get(v.id, 0.0))
            if target == 'Local':
                t_tx = 0.0
            else:
                t_tx = float(np.clip(t_tx_raw, 0.0, self.config.DT))
            p_max_watt = self._get_p_max_watt(target)
            reward_parts = None
            if getattr(v, 'illegal_action', False):
                r = self.config.REWARD_MIN  # 非法动作给予最小奖励
                components = {
                    "delay_norm": 0.0,
                    "energy_norm": 0.0,
                    "r_soft_pen": 0.0,
                    "r_timeout": 0.0,
                    "hard_triggered": False,
                }
                hard_triggered = False
                reward_parts = compute_absolute_reward(
                    dT_rem, 0.0, power_ratio, self.config.DT, p_max_watt,
                    self.config.REWARD_MIN, self.config.REWARD_MAX, hard_triggered=True, illegal_action=True
                )[1]
                reward_parts["energy_norm"] = 0.0
                r = self._clip_reward(r)
            else:
                components = self._compute_cost_components(i, target, task_idx, task_comp)
                hard_triggered = components.get("hard_triggered", False)
                base_reward, reward_parts = compute_absolute_reward(
                    dT_rem, t_tx, power_ratio, self.config.DT, p_max_watt,
                    self.config.REWARD_MIN, self.config.REWARD_MAX, hard_triggered=hard_triggered, illegal_action=False
                )
                if hard_triggered:
                    reward_parts["energy_norm"] = 0.0
                r = self._clip_reward(base_reward)
            if hasattr(v, 'subtask_reward_buffer'):
                v.subtask_reward_buffer = 0.0

            self._episode_dT_eff_values.append(dT_eff)
            self._episode_energy_norm_values.append(reward_parts.get("energy_norm", 0.0) if reward_parts else 0.0)
            self._episode_t_tx_values.append(step_tx_time.get(v.id, 0.0))

            rewards.append(r)

        # =====================================================================
        # [强制续航] Episode终止逻辑
        # =====================================================================
        # 设计原则：
        # - 不因任务完成而提前终止episode
        # - 让环境完整运行到MAX_TIME（MAX_STEPS * DT）
        # 优势：
        # 1. 反映长期平均性能（包括空闲期和新任务）
        # 2. 处理动态到达的新车辆任务
        # 3. 使Reward曲线更稳定、更真实
        # 4. 符合连续运行的真实场景（系统不会因为当前任务完成就停机）
        # =====================================================================
        all_finished = all(v.task_dag.is_finished for v in self.vehicles)
        time_limit_reached = self.steps >= self.config.MAX_STEPS
        
        # [修改] 强制续航：只有达到时间上限才终止
        terminated = False  # 不再使用all_finished作为终止条件
        truncated = time_limit_reached
        
        # 在info中记录任务完成状态（用于分析）
        info = {
            'timeout': time_limit_reached,
            'all_finished': all_finished,
            'num_active_vehicles': len([v for v in self.vehicles if not v.task_dag.is_finished]),
            'terminated_trigger': 'time_limit' if time_limit_reached else ('all_finished' if all_finished else 'none')
        }
        
        # [审计系统] 收集本步审计数据
        info['audit_step_info'] = self._collect_audit_step_info(commit_plans)
        
        # [P2性能统计] 在每个step末尾累计统计（无论是否终止）
        W_curr = self._get_total_W_remaining()
        deltaW = max(0.0, self._p2_W_prev - W_curr)  # 防止数值抖动造成负值
        total_active = self._get_total_active_tasks()
        
        if total_active > 0:
            self._p2_active_time += self.config.DT
            self._p2_deltaW_active += deltaW
            # 检测长时间无推进
            if deltaW < 1e-6:  # 几乎没有推进
                self._p2_zero_delta_steps += 1
            else:
                self._p2_zero_delta_steps = 0
        else:
            self._p2_idle_time += self.config.DT
        
        self._p2_W_prev = W_curr
        
        # [一致性检查] 长时间无推进警告
        if self._p2_zero_delta_steps >= 50 and total_active > 0:
            import warnings
            warnings.warn(
                f"[P2警告] 连续{self._p2_zero_delta_steps}步活跃任务未推进，"
                f"total_active={total_active}, deltaW={deltaW:.2e}",
                UserWarning
            )
            self._p2_zero_delta_steps = 0  # 重置计数，避免重复警告

        if terminated or truncated:
            # [Miss Reason分解] 在episode结束时标记失败原因
            for v in self.vehicles:
                if v.task_dag.is_finished:
                    continue  # 已完成的跳过
                
                # 如果任务已标记failed但没有fail_reason，强制设为deadline
                if v.task_dag.is_failed and not v.task_dag.fail_reason:
                    v.task_dag.fail_reason = 'deadline'
                
                # 未标记failed的任务，根据情况设置原因
                if not v.task_dag.is_failed:
                    # 检查是否有illegal action
                    if hasattr(v, 'illegal_action') and v.illegal_action:
                        v.task_dag.set_failed(reason='illegal')
                    # 检查是否有overflow（队列满）
                    elif hasattr(v, 'illegal_reason') and v.illegal_reason and 'overflow' in v.illegal_reason.lower():
                        v.task_dag.set_failed(reason='overflow')
                    # 其他未标记的保留（在_log_episode_stats中会归为unfinished或truncated）
            
            # [P2性能统计] 在每个step末尾累计统计
            W_curr = self._get_total_W_remaining()
            deltaW = max(0.0, self._p2_W_prev - W_curr)  # 防止数值抖动造成负值
            total_active = self._get_total_active_tasks()
            
            if total_active > 0:
                self._p2_active_time += self.config.DT
                self._p2_deltaW_active += deltaW
                # 检测长时间无推进
                if deltaW < 1e-6:  # 几乎没有推进
                    self._p2_zero_delta_steps += 1
                else:
                    self._p2_zero_delta_steps = 0
            else:
                self._p2_idle_time += self.config.DT
            
            self._p2_W_prev = W_curr
            
            # [一致性检查] 长时间无推进警告
            if self._p2_zero_delta_steps >= 50 and total_active > 0:
                import warnings
                warnings.warn(
                    f"[P2警告] 连续{self._p2_zero_delta_steps}步活跃任务未推进，"
                    f"total_active={total_active}, deltaW={deltaW:.2e}",
                    UserWarning
                )
                self._p2_zero_delta_steps = 0  # 重置计数，避免重复警告
            
            self._log_episode_stats(terminated, truncated)
            
            # [P2/P0新增] 将关键健康指标写入info（供审计脚本使用）
            # 这些字段在_log_episode_stats中已计算并保存到_last_episode_metrics
            if hasattr(self, '_last_episode_metrics'):
                info['episode_metrics'] = self._last_episode_metrics.copy()
                # 同时直接在info顶层写入这些字段（向后兼容）
                info.update(self._last_episode_metrics)

        return self._get_obs(), rewards, terminated, truncated, info

    def _calculate_global_cft_critical_path(self):
        """
        [关键方法] 计算全局关键路径完成时间 (CFT)

        核心思想:
        - 考虑任务间的依赖关系 (DAG)
        - 考虑数据传输时间 (跨节点执行时)
        - 考虑历史执行位置 (通过 exec_locations 跟踪)

        缓存机制:
        - 如果仿真状态未变 (位置、队列等)，直接返回缓存的 CFT 值
        - 避免重复计算，提高效率
        """
        # 计算RSU队列状态（用于缓存哈希）
        rsu_queue_state = tuple(rsu.queue_length for rsu in self.rsus) if len(self.rsus) > 0 else (0,)
        
        current_state_hash = hash((
            round(self.time, 3),
            rsu_queue_state,
            tuple(round(v.pos[0], 2) for v in self.vehicles),
            tuple(round(v.pos[1], 2) for v in self.vehicles),
            tuple(v.task_queue_len for v in self.vehicles),
            tuple(v.curr_target if hasattr(v, 'curr_target') else None for v in self.vehicles)
        ))

        if (self._cft_cache is not None and
                self._cft_cache_valid and
                hasattr(self, '_cft_state_hash') and
                self._cft_state_hash == current_state_hash):
            return self._cft_cache

        self._cft_state_hash = current_state_hash

        total_cft = 0.0

        for v in self.vehicles:
            if v.task_dag.is_finished:
                total_cft = max(total_cft, self.time)
                continue

            dag = v.task_dag
            num_tasks = dag.num_subtasks
            if num_tasks == 0: continue

            adj = dag.adj
            data_matrix = dag.data_matrix
            rem_comps = dag.rem_comp

            task_locations = ['Local'] * num_tasks

            if hasattr(v, 'exec_locations'):
                for i in range(num_tasks):
                    if v.exec_locations[i] is not None:
                        task_locations[i] = v.exec_locations[i]

            for i in range(num_tasks):
                if task_locations[i] is None:
                    task_locations[i] = 'Local'

            if v.curr_subtask is not None and 0 <= v.curr_subtask < num_tasks:
                task_locations[v.curr_subtask] = v.curr_target

            # 使用FIFO队列计算等待时间
            local_wait = v.task_queue.get_estimated_wait_time(v.cpu_freq)
            # 多RSU场景：使用所有RSU中的最小等待时间
            if len(self.rsus) > 0:
                rsu_wait_global = min([rsu.get_estimated_wait_time() for rsu in self.rsus])
            else:
                rsu_wait_global = 0.0

            node_exec_times = np.zeros(num_tasks)
            cpu_fat = np.zeros(num_tasks)
            channel_fat = np.zeros(num_tasks)

            for i in range(num_tasks):
                if dag.status[i] == 3: continue

                loc = task_locations[i]
                if loc == 'Local':
                    node_exec_times[i] = rem_comps[i] / v.cpu_freq
                    cpu_fat[i] = local_wait
                    channel_fat[i] = 0.0
                elif self._is_rsu_location(loc):
                    # 多RSU场景：使用对应RSU的CPU频率
                    rsu_id = self._get_rsu_id_from_location(loc)
                    if rsu_id is not None and 0 <= rsu_id < len(self.rsus):
                        rsu = self.rsus[rsu_id]
                        node_exec_times[i] = rem_comps[i] / rsu.cpu_freq
                        cpu_fat[i] = rsu.get_estimated_wait_time()
                    else:
                        # 向后兼容：使用默认RSU频率
                        node_exec_times[i] = rem_comps[i] / self.config.F_RSU
                        cpu_fat[i] = rsu_wait_global
                    channel_fat[i] = 0.0
                elif isinstance(loc, int):
                    target_veh = self._get_vehicle_by_id(loc)
                    if target_veh is None:
                        target_veh = v
                    wait_target = target_veh.task_queue.get_estimated_wait_time(target_veh.cpu_freq)
                    node_exec_times[i] = rem_comps[i] / target_veh.cpu_freq
                    cpu_fat[i] = wait_target
                    channel_fat[i] = 0.0

            earliest_start = np.zeros(num_tasks)

            for i in range(num_tasks):
                if dag.status[i] == 3: continue

                preds = np.where(adj[:, i] == 1)[0]
                max_pred_finish = 0.0

                for p in preds:
                    pred_loc = task_locations[p]
                    curr_loc = task_locations[i]

                    pred_finish = earliest_start[p] + node_exec_times[p]

                    # 判断是否在同一位置（支持RSU元组）
                    if self._is_rsu_location(pred_loc) and self._is_rsu_location(curr_loc):
                        rsu_id_p = self._get_rsu_id_from_location(pred_loc)
                        rsu_id_c = self._get_rsu_id_from_location(curr_loc)
                        same_location = (rsu_id_p is not None and rsu_id_p == rsu_id_c)
                    elif pred_loc == 'Local' and curr_loc == 'Local':
                        same_location = True
                    elif isinstance(pred_loc, int) and isinstance(curr_loc, int):
                        same_location = (pred_loc == curr_loc)
                    else:
                        same_location = False

                    if same_location:
                        data_transfer_time = 0.0
                    else:
                        transfer_data = data_matrix[p, i]
                        if transfer_data <= 1e-9:
                            data_transfer_time = 0.0
                        else:
                            # 获取RSU位置（如果是RSU目标）
                            rsu_pos = self.config.RSU_POS  # 默认使用配置位置（向后兼容）
                            if self._is_rsu_location(curr_loc):
                                rsu_id = self._get_rsu_id_from_location(curr_loc)
                                if rsu_id is not None and 0 <= rsu_id < len(self.rsus):
                                    rsu_pos = self.rsus[rsu_id].position
                            est_rate = self._get_comm_rate(v, p, curr_loc, rsu_pos)
                            data_transfer_time = transfer_data / est_rate

                    max_pred_finish = max(max_pred_finish, pred_finish + data_transfer_time)

                est_i = max(cpu_fat[i], channel_fat[i], max_pred_finish)
                earliest_start[i] = est_i

            max_completion_time = 0.0
            estimated_failed = False

            for i in range(num_tasks):
                if dag.status[i] == 3: continue

                completion_time = earliest_start[i] + node_exec_times[i]
                max_completion_time = max(max_completion_time, completion_time)

            if dag.deadline > 0 and max_completion_time > dag.deadline:
                estimated_failed = True

            total_cft = max(total_cft, max_completion_time)

        self._cft_cache = total_cft
        self._cft_cache_time = self.time
        self._cft_cache_valid = True
        return total_cft

    def _get_dist_matrix(self):
        """计算并缓存所有车辆间的距离矩阵

        优化: 避免在_get_obs中重复计算车辆间距离
        缓存: 同一时间步内复用
        """
        if (self._dist_matrix_cache is not None and
            abs(self.time - self._dist_matrix_time) < 1e-6):
            return self._dist_matrix_cache

        num_vehicles = len(self.vehicles)
        if num_vehicles == 0:
            self._dist_matrix_cache = np.zeros((0, 0))
            self._dist_matrix_time = self.time
            return self._dist_matrix_cache

        positions = np.array([v.pos for v in self.vehicles])
        # 使用numpy广播完全向量化计算距离矩阵
        # positions[:, None, :] 形状 (N, 1, 2)
        # positions[None, :, :] 形状 (1, N, 2)
        # 广播后 diff 形状 (N, N, 2)
        diff = positions[:, None, :] - positions[None, :, :]
        self._dist_matrix_cache = np.linalg.norm(diff, axis=2)  # (N, N)

        self._dist_matrix_time = self.time
        return self._dist_matrix_cache

    def _get_rsu_dist(self, vehicle):
        """获取车辆到最近RSU的距离（使用实际RSU列表）"""
        if vehicle.id in self._rsu_dist_cache:
            return self._rsu_dist_cache[vehicle.id]
        
        # 使用实际部署的RSU列表计算最近距离
        if len(self.rsus) > 0:
            min_dist = float('inf')
            for rsu in self.rsus:
                dist = rsu.get_distance(vehicle.pos)
                if dist < min_dist:
                    min_dist = dist
            dist = min_dist
        else:
            # 向后兼容：没有RSU时使用配置
            dist = np.linalg.norm(vehicle.pos - self.config.RSU_POS)
        
        self._rsu_dist_cache[vehicle.id] = dist
        return dist

    def _get_obs(self):
        """[关键方法] 生成所有车辆的观测

        观测组成:
        - node_x: 子任务级特征 (DAG属性)
        - self_info: 车辆级特征 (自身状态)
        - rsu_info: 环境级特征 (RSU负载)
        - adj: 图结构 (任务依赖)
        - neighbors: 邻居特征 (V2V通信候选)
        - task_mask: 可调度任务 (READY状态)
        - target_mask: 合法动作 (位置有效、队列未满)

        维度约束:
        - neighbors使用固定维度填充 (MAX_NEIGHBORS, 8)
        - 满足Gymnasium批处理要求
        """
        obs_list = []
        dist_matrix = self._get_dist_matrix()
        vehicle_ids = [veh.id for veh in self.vehicles]
        step_avail_l = 0.0
        step_avail_r = 0.0
        step_avail_v = 0.0
        step_neighbor_sum = 0.0
        step_best_v2v_sum = 0.0
        step_best_v2v_valid = 0

        for v in self.vehicles:
            v_idx = vehicle_ids.index(v.id)
            num_nodes = v.task_dag.num_subtasks
            elapsed = self.time - v.task_dag.start_time
            t_rem = v.task_dag.deadline - elapsed
            t_total = v.task_dag.deadline if v.task_dag.deadline > 0 else 1.0

            val_t_rem = np.clip(t_rem, -10.0, 10.0)
            val_urgency = np.clip(t_rem / t_total, 0.0, 1.0) if t_rem > 0 else 0.0

            feat_t_rem = np.full(num_nodes, val_t_rem)
            feat_urgency = np.full(num_nodes, val_urgency)
            feat_in_degree = v.task_dag.in_degree * self._inv_max_nodes
            out_degree_arr = v.task_dag.out_degree if hasattr(v.task_dag, 'out_degree') else np.sum(v.task_dag.adj, axis=1)
            feat_out_degree = out_degree_arr * self._inv_max_nodes
            feat_status = v.task_dag.status / 3.0

            node_feats = np.stack([
                v.task_dag.rem_comp * self._inv_max_comp,
                v.task_dag.rem_data * self._inv_max_data,
                feat_status,
                feat_in_degree,
                feat_out_degree,
                (feat_t_rem + 10.0) / 20.0,
                feat_urgency
            ], axis=1)

            # [关键] 固定维度填充 - 适配批处理要求
            # 将node特征填充到固定维度MAX_NODES，确保所有车辆观测形状一致
            MAX_NODES = self.config.MAX_NODES
            node_dim = 7
            padded_node_feats = np.zeros((MAX_NODES, node_dim), dtype=np.float32)
            padded_node_feats[:num_nodes, :] = node_feats

            dist_rsu = self._get_rsu_dist(v)
            # 多RSU场景：使用最近RSU的位置计算V2I速率
            if len(self.rsus) > 0:
                min_dist = float('inf')
                nearest_rsu_pos = self.config.RSU_POS
                for rsu in self.rsus:
                    if rsu.is_in_coverage(v.pos):
                        dist = rsu.get_distance(v.pos)
                        if dist < min_dist:
                            min_dist = dist
                            nearest_rsu_pos = rsu.position
                rsu_pos_for_v2i = nearest_rsu_pos
            else:
                rsu_pos_for_v2i = self.config.RSU_POS
            est_v2i_rate = self.channel.compute_one_rate(
                v, rsu_pos_for_v2i, 'V2I', curr_time=self.time,
                v2i_user_count=self._estimate_v2i_users()
            )
            # [处理器共享] 使用新的延迟估算方法
            self_wait = self._get_node_delay(v)

            self_info = np.array([
                v.vel[0] * self._inv_max_velocity, v.vel[1] * self._inv_max_velocity,
                np.clip(self_wait * self._inv_max_wait, 0, 1),
                v.cpu_freq * self._inv_max_cpu,
                np.clip(est_v2i_rate * self._inv_max_rate_v2i, 0, 1),
                v.pos[0] * self._inv_map_size, v.pos[1] * self._inv_map_size
            ], dtype=np.float32)

            task_schedulable = v.task_dag.get_action_mask()
            
            # [新设计] 环境自动选择优先级最高的任务
            selected_subtask_idx = v.task_dag.get_top_priority_task()
            if selected_subtask_idx is None:
                # 没有可调度的任务，使用无效索引-1
                selected_subtask_idx = -1

            if selected_subtask_idx >= 0 and selected_subtask_idx < v.task_dag.num_subtasks:
                task_data_size = v.task_dag.total_data[selected_subtask_idx]
                task_comp_size = v.task_dag.total_comp[selected_subtask_idx]
            else:
                task_data_size = float(np.mean(v.task_dag.total_data)) if v.task_dag.total_data.size > 0 else 0.0
                task_comp_size = float(np.mean(v.task_dag.total_comp)) if v.task_dag.total_comp.size > 0 else self.config.MEAN_COMP_LOAD

            rsu_id, rsu_rate, rsu_wait, rsu_dist, rsu_contact = self._select_best_rsu(
                v, task_comp_size, task_data_size
            )
            rsu_available = rsu_id is not None
            rsu_load_norm = np.clip(rsu_wait * self._inv_max_wait, 0, 1) if rsu_available else 0.0
            rsu_total_time = None
            if rsu_available:
                rsu_cpu = self.rsus[rsu_id].cpu_freq if (self.rsus and rsu_id < len(self.rsus)) else self.config.F_RSU
                rsu_tx_time = (task_data_size / max(rsu_rate, 1e-6)) if task_data_size > 0 else 0.0
                rsu_comp_time = task_comp_size / max(rsu_cpu, 1e-6)
                rsu_total_time = (rsu_tx_time + rsu_wait + rsu_comp_time) * 1.0

            neighbor_dim = 8
            neighbors_array = np.zeros((self.config.MAX_NEIGHBORS, neighbor_dim), dtype=np.float32)
            candidate_info = []

            for j, other in enumerate(self.vehicles):
                if v.id == other.id:
                    continue
                dist = dist_matrix[v_idx, j]
                if dist > self.config.V2V_RANGE:
                    continue

                if other.is_queue_full(new_task_cycles=task_comp_size):
                    continue

                est_v2v_rate = self.channel.compute_one_rate(v, other.pos, 'V2V', self.time)
                est_v2v_rate = max(est_v2v_rate, 1e-6)
                trans_time = task_data_size / est_v2v_rate if task_data_size > 0 else 0.0
                # [处理器共享] 使用新的延迟估算方法
                queue_wait_time = self._get_node_delay(other)
                comp_time = task_comp_size / max(other.cpu_freq, 1e-6)
                total_task_time = (trans_time + queue_wait_time + comp_time) * 1.2

                rel_vel = other.vel - v.vel
                pos_diff = other.pos - v.pos
                pos_diff_norm = np.linalg.norm(pos_diff)
                if pos_diff_norm < 1e-6:
                    time_to_break = self._max_v2v_contact_time
                else:
                    rel_vel_proj = np.dot(rel_vel, pos_diff) / pos_diff_norm
                    if rel_vel_proj > 0.1:
                        time_to_break = (self.config.V2V_RANGE - dist) / rel_vel_proj
                    else:
                        time_to_break = self._max_v2v_contact_time

                if total_task_time > time_to_break:
                    continue

                rel_pos = (other.pos - v.pos) * self._inv_v2v_range
                candidate_info.append({
                    'id': other.id,
                    'dist': dist,
                    'rel_pos': rel_pos,
                    'vel': other.vel,
                    'queue_wait': queue_wait_time,
                    'cpu_freq': other.cpu_freq,
                    'rate': est_v2v_rate,
                    'contact_time': max(time_to_break, 0.0),
                    'total_time': total_task_time
                })

            candidate_info.sort(key=lambda x: (x['total_time'], x['dist']))
            neighbor_count = len(candidate_info)

            candidate_ids = [-1] * self.config.MAX_NEIGHBORS
            for idx, info in enumerate(candidate_info[:self.config.MAX_NEIGHBORS]):
                candidate_ids[idx] = info['id']
                neighbors_array[idx] = [
                    info['id'], info['rel_pos'][0], info['rel_pos'][1],
                    info['vel'][0] * self._inv_max_velocity, info['vel'][1] * self._inv_max_velocity,
                    np.clip(info['queue_wait'] * self._inv_max_wait, 0, 1),
                    info['cpu_freq'] * self._inv_max_cpu,
                    np.clip(info['rate'] * self._inv_max_rate_v2v, 0, 1)
                ]

            target_mask_row = np.zeros(self.config.MAX_TARGETS, dtype=bool)
            target_mask_row[0] = True
            target_mask_row[1] = rsu_available
            for idx, candidate_id in enumerate(candidate_ids):
                if candidate_id >= 0:
                    target_mask_row[2 + idx] = True

            # [关键] 死锁兜底：如果所有目标都不可用，强制开启Local
            if not np.any(target_mask_row):
                target_mask_row[0] = True
            
            # [审计] 保存mask到vehicle对象，用于审计收集
            v._last_action_mask = target_mask_row.copy()

            resource_id_list = np.zeros(self.config.MAX_TARGETS, dtype=np.int64)
            resource_id_list[0] = 1
            resource_id_list[1] = 2
            for idx, candidate_id in enumerate(candidate_ids):
                if candidate_id >= 0:
                    resource_id_list[2 + idx] = 3 + candidate_id

            padded_target_mask = target_mask_row.copy()

            assert len(target_mask_row) == self.config.MAX_TARGETS, "target_mask length mismatch"
            assert len(candidate_ids) == self.config.MAX_NEIGHBORS, "candidate_ids length mismatch"
            for idx, candidate_id in enumerate(candidate_ids):
                expected_id = 0 if candidate_id < 0 else 3 + candidate_id
                assert resource_id_list[2 + idx] == expected_id, "resource_id_list mismatch"
                assert target_mask_row[2 + idx] == (candidate_id >= 0), "target_mask mismatch"

            step_avail_l += 1.0 if target_mask_row[0] else 0.0
            step_avail_r += 1.0 if target_mask_row[1] else 0.0
            if self.config.MAX_NEIGHBORS > 0:
                step_avail_v += float(np.mean(target_mask_row[2:]))
            step_neighbor_sum += float(neighbor_count)
            if neighbor_count > 0:
                best_rate = max(info['rate'] for info in candidate_info)
                step_best_v2v_sum += float(best_rate)
                step_best_v2v_valid += 1
            if neighbor_count > 0 and rsu_total_time is not None:
                min_v2v_time = min(info["total_time"] for info in candidate_info)
                if min_v2v_time < rsu_total_time:
                    pass  # 已清理诊断统计

            self._last_candidates[v.id] = candidate_ids
            self._last_rsu_choice[v.id] = rsu_id

            resource_raw = np.zeros((self.config.MAX_TARGETS, self.config.RESOURCE_RAW_DIM), dtype=np.float32)
            slack_norm = val_urgency

            # Local节点特征：计算时间预估
            local_est_exec = task_comp_size / max(v.cpu_freq, 1e-6) if task_comp_size > 0 else 0.0
            local_est_comm = 0.0  # Local无传输
            local_est_wait = self_wait
            
            resource_raw[0] = [
                v.cpu_freq * self._inv_max_cpu,
                np.clip(self_wait * self._inv_max_wait, 0, 1),
                0.0,  # 距离为0
                0.0,  # [修复] Local无传输，Rate=0而非1
                0.0,  # 相对位置X
                0.0,  # 相对位置Y
                v.vel[0] * self._inv_max_velocity,
                v.vel[1] * self._inv_max_velocity,
                1.0,  # Node_Type = 1 (Local)
                slack_norm,
                1.0,  # Contact永久连接
                np.clip(local_est_exec / 10.0, 0, 1),  # Est_Exec_Time
                np.clip(local_est_comm / 10.0, 0, 1),  # Est_Comm_Time
                np.clip(local_est_wait / 10.0, 0, 1)   # Est_Wait_Time
            ]

            if rsu_available:
                rsu = self.rsus[rsu_id]
                rel_rsu = (rsu.position - v.pos) * self._inv_map_size
                rsu_contact_norm = np.clip(rsu_contact / max(self._max_rsu_contact_time, 1e-6), 0, 1)
                
                # RSU节点特征：计算时间预估
                rsu_cpu = rsu.cpu_freq if rsu else self.config.F_RSU
                rsu_est_exec = task_comp_size / max(rsu_cpu, 1e-6) if task_comp_size > 0 else 0.0
                rsu_est_comm = task_data_size / max(rsu_rate, 1e-6) if task_data_size > 0 else 0.0
                rsu_est_wait = rsu_wait
                
                resource_raw[1] = [
                    rsu.cpu_freq * self._inv_max_cpu,
                    np.clip(rsu_wait * self._inv_max_wait, 0, 1),
                    np.clip(rsu_dist / max(self.config.RSU_RANGE, 1e-6), 0, 1),
                    np.clip(rsu_rate * self._inv_max_rate_v2i, 0, 1),
                    rel_rsu[0],
                    rel_rsu[1],
                    0.0,  # RSU速度为0
                    0.0,  # RSU速度为0
                    2.0,  # Node_Type = 2 (RSU)
                    slack_norm,
                    rsu_contact_norm,
                    np.clip(rsu_est_exec / 10.0, 0, 1),  # Est_Exec_Time
                    np.clip(rsu_est_comm / 10.0, 0, 1),  # Est_Comm_Time
                    np.clip(rsu_est_wait / 10.0, 0, 1)   # Est_Wait_Time
                ]

            for idx, info in enumerate(candidate_info[:self.config.MAX_NEIGHBORS]):
                contact_norm = np.clip(info['contact_time'] / max(self._max_v2v_contact_time, 1e-6), 0, 1)
                
                # Neighbor节点特征：计算时间预估
                neighbor_est_exec = task_comp_size / max(info['cpu_freq'], 1e-6) if task_comp_size > 0 else 0.0
                neighbor_est_comm = task_data_size / max(info['rate'], 1e-6) if task_data_size > 0 else 0.0
                neighbor_est_wait = info['queue_wait']
                
                resource_raw[2 + idx] = [
                    info['cpu_freq'] * self._inv_max_cpu,
                    np.clip(info['queue_wait'] * self._inv_max_wait, 0, 1),
                    np.clip(info['dist'] * self._inv_v2v_range, 0, 1),
                    np.clip(info['rate'] * self._inv_max_rate_v2v, 0, 1),
                    info['rel_pos'][0],
                    info['rel_pos'][1],
                    info['vel'][0] * self._inv_max_velocity,
                    info['vel'][1] * self._inv_max_velocity,
                    3.0,  # Node_Type = 3 (Neighbor)
                    slack_norm,
                    contact_norm,
                    np.clip(neighbor_est_exec / 10.0, 0, 1),  # Est_Exec_Time
                    np.clip(neighbor_est_comm / 10.0, 0, 1),  # Est_Comm_Time
                    np.clip(neighbor_est_wait / 10.0, 0, 1)   # Est_Wait_Time
                ]

            # [关键] 固定维度填充 - 适配批处理要求
            padded_adj = np.zeros((self.config.MAX_NODES, self.config.MAX_NODES), dtype=np.float32)
            padded_adj[:num_nodes, :num_nodes] = v.task_dag.adj

            padded_task_mask = np.zeros(self.config.MAX_NODES, dtype=bool)
            padded_task_mask[:num_nodes] = task_schedulable
            
            # [新增] DAG拓扑特征（用于网络特征工程）
            # L_fwd, L_bwd: [MAX_NODES], 前向/后向层级
            padded_L_fwd = np.zeros(MAX_NODES, dtype=np.int32)
            padded_L_bwd = np.zeros(MAX_NODES, dtype=np.int32)
            padded_L_fwd[:num_nodes] = v.task_dag.L_fwd
            padded_L_bwd[:num_nodes] = v.task_dag.L_bwd
            
            # data_matrix: [MAX_NODES, MAX_NODES], 边数据量
            padded_data_matrix = np.zeros((MAX_NODES, MAX_NODES), dtype=np.float32)
            edge_max = max(getattr(Cfg, 'MAX_EDGE_DATA', 1.0), 1.0)
            edge_norm = np.log1p(v.task_dag.data_matrix) / np.log1p(edge_max)
            padded_data_matrix[:num_nodes, :num_nodes] = np.clip(edge_norm, 0.0, 1.0)
            
            # Delta: [MAX_NODES, MAX_NODES], 最短路径距离
            padded_Delta = np.zeros((MAX_NODES, MAX_NODES), dtype=np.int32)
            padded_Delta[:num_nodes, :num_nodes] = v.task_dag.Delta
            
            # status: [MAX_NODES], 任务状态（0-3）
            padded_status = np.zeros(MAX_NODES, dtype=np.int32)
            padded_status[:num_nodes] = v.task_dag.status
            
            # location: [MAX_NODES], 任务执行位置编码
            # 0: Unscheduled, 1: Local, 2: RSU, 3+: Neighbor vehicle ID
            padded_location = np.zeros(MAX_NODES, dtype=np.int32)
            for t_idx in range(num_nodes):
                # 优先从v.exec_locations获取（Vehicle属性），其次是v.task_dag.task_locations
                if hasattr(v, 'exec_locations') and v.exec_locations[t_idx] is not None:
                    loc = v.exec_locations[t_idx]
                elif hasattr(v.task_dag, 'task_locations') and v.task_dag.task_locations[t_idx] is not None:
                    loc = v.task_dag.task_locations[t_idx]
                else:
                    loc = None
                
                if loc is None or loc == 'None':
                    padded_location[t_idx] = 0  # Unscheduled
                elif loc == 'Local':
                    padded_location[t_idx] = 1
                elif self._is_rsu_location(loc):
                    padded_location[t_idx] = 2
                elif isinstance(loc, int):
                    padded_location[t_idx] = 3 + loc  # Neighbor vehicle ID
                else:
                    padded_location[t_idx] = 0

            obs_list.append({
                'node_x': padded_node_feats,
                'self_info': self_info,
                'rsu_info': [rsu_load_norm],
                'adj': padded_adj,
                'neighbors': neighbors_array,
                'task_mask': padded_task_mask,
                'target_mask': padded_target_mask,  # [新设计] 简化为[2+MAX_NEIGHBORS]
                'action_mask': padded_target_mask.copy(),  # [新增] Actor专用动作掩码
                'resource_ids': resource_id_list,  # [新增] 资源节点ID列表
                'resource_raw': resource_raw,  # [新增] 资源原始物理特征
                'subtask_index': int(selected_subtask_idx),  # [新设计] 添加当前选中的任务索引
                # [新增] DAG拓扑特征
                'L_fwd': padded_L_fwd,
                'L_bwd': padded_L_bwd,
                'data_matrix': padded_data_matrix,
                'Delta': padded_Delta,
                'status': padded_status,
                'location': padded_location,
                'obs_stamp': int(self._episode_steps)
            })

        self._last_obs_stamp = int(self._episode_steps)
        num_veh = max(len(self.vehicles), 1)
        if step_best_v2v_valid > 0:
            pass  # 已清理
        return obs_list

    def _estimate_v2i_users(self):
        """
        估算当前活跃的V2I上传用户数，用于带宽均分与噪声计算保持一致
        """
        count = 0
        for veh in self.vehicles:
            tgt = getattr(veh, 'curr_target', None)
            if tgt == 'RSU':
                count += 1
            elif isinstance(tgt, tuple) and len(tgt) == 2 and tgt[0] == 'RSU':
                count += 1
        return max(count, 1)

    def _get_comm_rate(self, vehicle, pred_task_id, curr_loc, rsu_pos):
        """计算任务间通信速率（简化接口，向后兼容）"""
        return self._get_inter_task_comm_rate(vehicle, pred_task_id, 0, 'Local', curr_loc)

    def _get_inter_task_comm_rate(self, vehicle, pred_task_id, curr_task_id, pred_loc, curr_loc):
        """[关键方法] 计算任务间通信速率

        通信场景:
        - Local->Local: 同地执行，无传输需求 (返回inf)
        - V2V: 基于距离和信道模型计算速率
        - V2I: 基于V2I信道模型计算速率
        - RSU参与: 使用V2I链路

        缓存优化:
        - 同一时间步内相同位置对的查询结果会被缓存
        - 避免重复计算信道速率
        """
        if pred_loc == curr_loc:
            return float('inf')

        time_key = int(self.time * 10)
        cache_key = (vehicle.id, str(pred_loc), str(curr_loc), time_key)
        if cache_key in self._comm_rate_cache:
            return self._comm_rate_cache[cache_key]

        tx_veh = None
        rx_veh = None

        if pred_loc == 'Local':
            tx_veh = vehicle
        elif isinstance(pred_loc, int):
            tx_veh = self._get_vehicle_by_id(pred_loc)

        if curr_loc == 'Local':
            rx_veh = vehicle
        elif isinstance(curr_loc, int):
            rx_veh = self._get_vehicle_by_id(curr_loc)

        rate = 1e-6

        if pred_loc == 'RSU' or curr_loc == 'RSU':
            # 确定目标位置（如果是RSU）
            if self._is_rsu_location(pred_loc):
                rsu_id = self._get_rsu_id_from_location(pred_loc)
                if rsu_id is not None and 0 <= rsu_id < len(self.rsus):
                    rsu_pos = self.rsus[rsu_id].position
                else:
                    rsu_pos = self.config.RSU_POS  # 向后兼容
                target_veh = rx_veh if rx_veh else (tx_veh if tx_veh else self.vehicles[0] if len(self.vehicles) > 0 else None)
                if target_veh:
                    rate = self.channel.compute_one_rate(
                        target_veh, rsu_pos, 'V2I', self.time,
                        v2i_user_count=self._estimate_v2i_users()
                    )
                else:
                    rate = 1e6
            elif self._is_rsu_location(curr_loc):
                rsu_id = self._get_rsu_id_from_location(curr_loc)
                if rsu_id is not None and 0 <= rsu_id < len(self.rsus):
                    rsu_pos = self.rsus[rsu_id].position
                else:
                    rsu_pos = self.config.RSU_POS  # 向后兼容
                target_veh = tx_veh if tx_veh else (rx_veh if rx_veh else self.vehicles[0] if len(self.vehicles) > 0 else None)
                if target_veh:
                    rate = self.channel.compute_one_rate(
                        target_veh, rsu_pos, 'V2I', self.time,
                        v2i_user_count=self._estimate_v2i_users()
                    )
                else:
                    rate = 1e6
            else:
                # 向后兼容：使用默认RSU位置
                target_veh = rx_veh if rx_veh else tx_veh
                if target_veh:
                    rate = self.channel.compute_one_rate(
                        target_veh, self.config.RSU_POS, 'V2I', self.time,
                        v2i_user_count=self._estimate_v2i_users()
                    )
                else:
                    rate = 1e6
        else:
            # V2V通信
            if tx_veh and rx_veh:
                dist = np.linalg.norm(tx_veh.pos - rx_veh.pos)
                if dist <= self.config.V2V_RANGE:
                    rate = self.channel.compute_one_rate(tx_veh, rx_veh.pos, 'V2V', self.time)
                else:
                    rate = 1e-6
            else:
                rate = 1e-6
        final_rate = max(rate, 1e-6)
        self._comm_rate_cache[cache_key] = final_rate
        return final_rate

    def _calculate_local_execution_time(self, dag, vehicle_id=0):
        """
        [奖励函数辅助] 计算任务在本地执行的预估时间

        包含排队时延，与 _estimate_execution_time() 保持一致

        Args:
            dag: DAGTask 对象
            vehicle_id: 车辆ID，用于获取队列长度和CPU频率

        Returns:
            float: 本地执行总时间 (考虑关键路径和排队时延)
        """
        if dag.num_subtasks == 0:
            return 0.0

        if vehicle_id < len(self.vehicles):
            v = self.vehicles[vehicle_id]
            wait_time = v.task_queue.get_estimated_wait_time(v.cpu_freq)
            freq = v.cpu_freq
        else:
            freq = self.config.MIN_VEHICLE_CPU_FREQ
            wait_time = 0.0

        node_comp = dag.total_comp
        local_exec_times = node_comp / freq

        critical_path_time = self._calc_critical_path_local(dag, local_exec_times)

        return critical_path_time + wait_time

    def _calc_critical_path_local(self, dag, exec_times):
        """
        [私有方法] 计算本地执行的关键路径时间（用于 r_eff 计算）
        """
        num_tasks = dag.num_subtasks
        in_degree = dag.in_degree.copy()

        ready_indices = np.where(in_degree == 0)[0]
        if len(ready_indices) == 0:
            return 0.0

        est = np.zeros(num_tasks)
        completed = set()

        for _ in range(num_tasks):
            if len(ready_indices) == 0:
                break
            i = ready_indices[0]
            ready_indices = ready_indices[1:]

            max_pred_finish = 0.0
            for pred in range(num_tasks):
                if dag.adj[pred, i] > 0:
                    data_size = dag.data_matrix[pred, i]
                    trans_time = 0.0
                    max_pred_finish = max(max_pred_finish, est[pred] + exec_times[pred] + trans_time)

            est[i] = max_pred_finish + exec_times[i]
            completed.add(i)

            for succ in range(num_tasks):
                if dag.adj[i, succ] > 0 and succ not in completed:
                    in_degree[succ] -= 1
                    if in_degree[succ] == 0:
                        ready_indices = np.append(ready_indices, succ)

        return np.max(est) if len(est) > 0 else 0.0

    def _calculate_efficiency_gain(self, dag, target, task_idx=None, vehicle_id=None):
        """
        [奖励函数组件] 计算效率收益 r_eff

        基于 MAPPO 设计:
        r_eff = tanh(λ * (T_local - T_exec) / T_local)

        Args:
            dag: 当前车辆的 DAG
            target: 目标执行位置 ('Local', 'RSU', 或车辆ID)
            task_idx: 当前调度的任务索引
            vehicle_id: 车辆ID（用于计算本地执行时间）

        Returns:
            float: 效率收益值 ∈ (-1, 1)
        """
        if vehicle_id is None:
            vehicle_id = 0
        
        t_local = self._calculate_local_execution_time(dag, vehicle_id)
        if t_local <= 0:
            return 0.0

        # 处理target格式：'Local', 'RSU', int车辆ID, 或('RSU', rsu_id)元组
        is_local = (target == 'Local')
        
        if is_local:
            # 本地执行时，效率收益为0（没有相对于本地执行的增益）
            gain_ratio = 0.0
        else:
            t_exec = self._estimate_execution_time(dag, target, task_idx, vehicle_id)
            if t_local > 0:
                gain_ratio = (t_local - t_exec) / t_local
            else:
                gain_ratio = 0.0

        eff_gain = np.tanh(self.config.EFF_SCALE * gain_ratio)

        return eff_gain

    def _estimate_execution_time(self, dag, target, task_idx=None, vehicle_id=None):
        """
        [奖励函数辅助] 估计在目标节点执行的时间

        包含: 传输时间 + 排队时间 + 计算时间
        
        Args:
            dag: DAG任务对象
            target: 目标执行位置
            task_idx: 任务索引
            vehicle_id: 车辆ID（用于获取车辆位置等信息）
        """
        if vehicle_id is None:
            vehicle_id = 0
        
        # 处理target格式：'Local', 'RSU', int车辆ID, 或('RSU', rsu_id)元组
        if target == 'Local':
            return self._calculate_local_execution_time(dag, vehicle_id)
        elif self._is_rsu_location(target):
            # RSU执行：多RSU场景或单个RSU场景
            if isinstance(target, tuple) and len(target) == 2:
                # 多RSU场景：使用指定的RSU
                rsu_id = target[1]
                if 0 <= rsu_id < len(self.rsus):
                    wait_time = self.rsus[rsu_id].get_estimated_wait_time()
                    freq = self.rsus[rsu_id].cpu_freq
                else:
                    wait_time = 0.0
                    freq = self.config.F_RSU
            else:
                # 单个RSU场景（向后兼容）
                if len(self.rsus) > 0:
                    wait_time = min([rsu.get_estimated_wait_time() for rsu in self.rsus])
                else:
                    wait_time = 0.0
                freq = self.config.F_RSU
        elif isinstance(target, int):
            # 其他车辆执行
            target_veh = self._get_vehicle_by_id(target)
            if target_veh is None:
                return self._calculate_local_execution_time(dag, vehicle_id)
            wait_time = target_veh.task_queue.get_estimated_wait_time(target_veh.cpu_freq)
            freq = target_veh.cpu_freq
        else:
            # 未知格式，默认本地执行
            return self._calculate_local_execution_time(dag, vehicle_id)

        total_comp = np.sum(dag.total_comp)
        comp_time = total_comp / freq

        trans_time = 0.0
        if task_idx is not None:
            input_data = dag.total_data[task_idx] if task_idx < len(dag.total_data) else 0.0
            if input_data > 0:
                # 使用正确的车辆位置
                if vehicle_id < len(self.vehicles):
                    veh_pos = self.vehicles[vehicle_id].pos
                else:
                    veh_pos = self.vehicles[0].pos if len(self.vehicles) > 0 else np.array([0, 0])
                
                # 处理target格式：'Local', 'RSU', int车辆ID, 或('RSU', rsu_id)元组
                if self._is_rsu_location(target):
                    # RSU执行
                    if isinstance(target, tuple) and len(target) == 2:
                        # 多RSU场景：使用指定的RSU位置
                        rsu_id = target[1]
                        if 0 <= rsu_id < len(self.rsus):
                            rsu_pos = self.rsus[rsu_id].position
                            dist = np.linalg.norm(veh_pos - rsu_pos)
                        else:
                            dist = 500.0  # 默认距离
                    else:
                        # 单个RSU场景（向后兼容）：使用最近RSU的距离
                        if len(self.rsus) > 0:
                            min_dist = min([np.linalg.norm(veh_pos - rsu.position) for rsu in self.rsus])
                            dist = min_dist
                        else:
                            dist = np.linalg.norm(veh_pos - self.config.RSU_POS) if len(self.vehicles) > 0 else 500.0
                    rate = self._estimate_rate(dist, 'V2I', target)
                elif isinstance(target, int):
                    # 其他车辆执行
                    tx_pos = veh_pos
                    target_veh = self._get_vehicle_by_id(target)
                    if target_veh is None:
                        rate = 1e6
                        trans_time = input_data / max(rate, 1e-6)
                        return wait_time + comp_time + trans_time
                    rx_pos = target_veh.pos
                    dist = np.linalg.norm(tx_pos - rx_pos)
                    rate = self._estimate_rate(dist, 'V2V', target)
                else:
                    # 未知格式，使用默认速率
                    rate = 1e6  # 默认高速率
                
                trans_time = input_data / max(rate, 1e-6)

        return wait_time + comp_time + trans_time

    def _estimate_rate(self, dist, link_type, target_id=None):
        """
        [通信模型辅助] 估计通信速率 (bits/s)

        使用简化的 Shannon 公式:
        rate = BW * log2(1 + SNR_linear)

        Args:
            dist: 通信距离 (m)
            link_type: 'V2I' 或 'V2V'
            target_id: 目标车辆ID (V2V 时使用)

        Returns:
            float: 通信速率 (bits/s)
        """
        if link_type == 'V2I':
            v2i_users = self._estimate_v2i_users()
            eff_bw = self.config.BW_V2I / max(v2i_users, 1)
            noise_w = self.channel._noise_power(eff_bw)
            h_bar = self.channel._path_loss(max(dist, 1.0), self.config.ALPHA_V2I)
            signal_w = self.config.dbm2watt(self.config.TX_POWER_MIN_DBM) * h_bar
            rate = eff_bw * np.log2(1 + signal_w / max(noise_w, 1e-12))
        else:
            h_bar = self.channel._path_loss(max(dist, 1.0), self.config.ALPHA_V2V)
            interference_w = self.config.dbm2watt(self.config.V2V_INTERFERENCE_DBM)
            noise_w = self.channel._noise_power(self.config.BW_V2V)
            signal_w = self.config.dbm2watt(self.config.TX_POWER_MIN_DBM) * h_bar
            rate = self.config.BW_V2V * np.log2(1 + signal_w / max(noise_w + interference_w, 1e-12))
        return rate

    def _calculate_congestion_penalty(self, target, task_comp=0, vehicle_id=None):
        """
        [奖励函数组件] 计算拥塞惩罚 r_cong（基于计算量）

        基于 MAPPO 设计:
        r_cong = -((Q_load + task_comp) / Q_max_load)^γ

        Args:
            target: 目标节点
            task_comp: 当前任务的计算量 (cycles)
            vehicle_id: 车辆ID（用于获取本地队列负载）

        Returns:
            float: 拥塞惩罚值 (≤ 0)
        """
        # 处理target格式：'Local', 'RSU', int车辆ID, 或('RSU', rsu_id)元组
        if target == 'Local':
            # 车辆本地队列
            if vehicle_id is not None and vehicle_id < len(self.vehicles):
                q_curr_load = self.vehicles[vehicle_id].task_queue.get_total_load()
                q_max_load = self.config.VEHICLE_QUEUE_CYCLES_LIMIT
            else:
                return 0.0
        elif self._is_rsu_location(target):
            # RSU执行
            if isinstance(target, tuple) and len(target) == 2:
                # 多RSU场景：使用指定的RSU队列计算量
                rsu_id = target[1]
                if 0 <= rsu_id < len(self.rsus):
                    q_curr_load = self.rsus[rsu_id].queue_manager.get_total_load()
                    q_max_load = self.config.RSU_QUEUE_CYCLES_LIMIT
                else:
                    return 0.0
            else:
                # 单个RSU场景（向后兼容）：使用所有RSU的总计算量
                q_curr_load = sum([rsu.queue_manager.get_total_load() for rsu in self.rsus]) if len(self.rsus) > 0 else 0
                q_max_load = self.config.RSU_QUEUE_CYCLES_LIMIT * len(self.rsus) if len(self.rsus) > 0 else self.config.RSU_QUEUE_CYCLES_LIMIT
        elif isinstance(target, int):
            target_veh = self._get_vehicle_by_id(target)
            if target_veh is None:
                return 0.0
            q_curr_load = target_veh.task_queue.get_total_load()
            q_max_load = self.config.VEHICLE_QUEUE_CYCLES_LIMIT
        else:
            return 0.0

        util_ratio = (q_curr_load + task_comp) / q_max_load
        util_ratio = np.clip(util_ratio, 0.0, 1.0)
        cong_penalty = -1.0 * (util_ratio ** self.config.CONG_GAMMA)

        return cong_penalty

    def _calculate_constraint_penalty(self, vehicle_id, target, task_idx=None, task_comp=None):
        """
        [奖励函数组件] 计算约束惩罚 r_pen
        
        采用"掩码覆盖"设计：
        - 硬约束触发时直接返回REWARD_MIN，不再计算软约束
        - 软约束（距离预警）提供梯度信息

        Args:
            vehicle_id: 车辆ID
            target: 目标节点
            task_idx: 任务索引
            task_comp: 任务计算量 (cycles)

        Returns:
            tuple: (soft_penalty, hard_constraint_triggered)
                - soft_penalty: 软约束惩罚（距离预警）
                - hard_constraint_triggered: 是否触发硬约束
        """
        soft_penalty = 0.0
        hard_triggered = False

        v = self.vehicles[vehicle_id]
        
        if task_comp is None:
            task_comp = self.config.MEAN_COMP_LOAD

        # ========== 硬约束检测 ==========
        # 1. RSU范围检查
        if self._is_rsu_location(target):
            in_range = False
            rsu_dist = float('inf')
            if isinstance(target, tuple) and len(target) == 2:
                rsu_id = target[1]
                if 0 <= rsu_id < len(self.rsus):
                    in_range = self.rsus[rsu_id].is_in_coverage(v.pos)
                    rsu_dist = np.linalg.norm(v.pos - self.rsus[rsu_id].position)
            else:
                if len(self.rsus) > 0:
                    for rsu in self.rsus:
                        if rsu.is_in_coverage(v.pos):
                            in_range = True
                            rsu_dist = min(rsu_dist, np.linalg.norm(v.pos - rsu.position))
                else:
                    dist = np.linalg.norm(v.pos - self.config.RSU_POS)
                    in_range = (dist <= self.config.RSU_RANGE)
                    rsu_dist = dist
            
            if not in_range:
                hard_triggered = True
            else:
                # 距离预警（软约束，固定启用）
                # Distance warning (soft constraint, permanently enabled)
                safe_dist = self.config.RSU_RANGE * self.config.DIST_SAFE_FACTOR
                if rsu_dist > safe_dist:
                    dist_ratio = (rsu_dist - safe_dist) / (self.config.RSU_RANGE - safe_dist + 1e-6)
                    dist_ratio = np.clip(dist_ratio, 0.0, 1.0)
                    soft_penalty += -self.config.DIST_PENALTY_WEIGHT * (dist_ratio ** self.config.DIST_SENSITIVITY)
        
        # 2. V2V范围检查
        elif isinstance(target, int):
            target_veh = self._get_vehicle_by_id(target)
            if target_veh is None:
                hard_triggered = True
            else:
                dist = np.linalg.norm(v.pos - target_veh.pos)
                
                if dist > self.config.V2V_RANGE:
                    hard_triggered = True
                else:
                    # 距离预警（软约束，固定启用）
                    # Distance warning (soft constraint, permanently enabled)
                    safe_dist = self.config.V2V_RANGE * self.config.DIST_SAFE_FACTOR
                    if dist > safe_dist:
                        dist_ratio = (dist - safe_dist) / (self.config.V2V_RANGE - safe_dist + 1e-6)
                        dist_ratio = np.clip(dist_ratio, 0.0, 1.0)
                        soft_penalty += -self.config.DIST_PENALTY_WEIGHT * (dist_ratio ** self.config.DIST_SENSITIVITY)

        # 3. 队列溢出检查（硬约束）
        if not hard_triggered:
            q_after_load = 0.0
            q_max_load = self.config.VEHICLE_QUEUE_CYCLES_LIMIT
            if target == 'Local':
                q_after_load = v.task_queue.get_total_load() + task_comp
                q_max_load = self.config.VEHICLE_QUEUE_CYCLES_LIMIT
            elif self._is_rsu_location(target):
                if isinstance(target, tuple) and len(target) == 2:
                    rsu_id = target[1]
                    if 0 <= rsu_id < len(self.rsus):
                        q_after_load = self.rsus[rsu_id].queue_manager.get_total_load() + task_comp
                    else:
                        q_after_load = task_comp
                    q_max_load = self.config.RSU_QUEUE_CYCLES_LIMIT
                else:
                    q_after_load = (sum([rsu.queue_manager.get_total_load() for rsu in self.rsus]) + task_comp) if len(self.rsus) > 0 else task_comp
                    q_max_load = self.config.RSU_QUEUE_CYCLES_LIMIT * len(self.rsus) if len(self.rsus) > 0 else self.config.RSU_QUEUE_CYCLES_LIMIT
            elif isinstance(target, int):
                target_veh = self._get_vehicle_by_id(target)
                if target_veh is not None:
                    q_after_load = target_veh.task_queue.get_total_load() + task_comp
                    q_max_load = self.config.VEHICLE_QUEUE_CYCLES_LIMIT
            
            if q_after_load > q_max_load:
                hard_triggered = True

        if hard_triggered:
            pass  # 已清理

        return soft_penalty, hard_triggered

    def _compute_cost_components(self, vehicle_id, target, task_idx=None, task_comp=None):
        v = self.vehicles[vehicle_id]
        dag = v.task_dag

        if task_comp is None:
            task_comp = self.config.MEAN_COMP_LOAD

        r_soft_pen, hard_triggered = self._calculate_constraint_penalty(vehicle_id, target, task_idx, task_comp)

        delay_norm = 0.0
        energy_norm = 0.0
        r_timeout = 0.0

        if task_idx is not None and 0 <= task_idx < dag.num_subtasks:
            task_comp = dag.total_comp[task_idx]
            task_data = dag.total_data[task_idx]

            max_rate = self.config.NORM_MAX_RATE_V2I
            if target == 'Local':
                queue_wait = v.task_queue.get_estimated_wait_time(v.cpu_freq)
                cpu_freq = v.cpu_freq
                tx_time = 0.0
                max_rate = self._get_norm_rate('V2I')
            elif self._is_rsu_location(target):
                rsu_id = self._get_rsu_id_from_location(target)
                if rsu_id is not None and 0 <= rsu_id < len(self.rsus):
                    rsu = self.rsus[rsu_id]
                    queue_wait = rsu.get_estimated_wait_time()
                    cpu_freq = rsu.cpu_freq
                    rate = self.channel.compute_one_rate(
                        v, rsu.position, 'V2I', self.time,
                        v2i_user_count=self._estimate_v2i_users()
                    )
                    rate = max(rate, 1e-6)
                    self._update_rate_norm(rate, 'V2I')
                    tx_time = task_data / rate if task_data > 0 else 0.0
                else:
                    queue_wait = 0.0
                    cpu_freq = v.cpu_freq
                    tx_time = 0.0
                max_rate = self._get_norm_rate('V2I')
            elif isinstance(target, int):
                t_veh = self._get_vehicle_by_id(target)
                if t_veh is None:
                    queue_wait = 0.0
                    cpu_freq = v.cpu_freq
                    tx_time = 0.0
                else:
                    queue_wait = t_veh.task_queue.get_estimated_wait_time(t_veh.cpu_freq)
                    cpu_freq = t_veh.cpu_freq
                    rate = self.channel.compute_one_rate(v, t_veh.pos, 'V2V', self.time)
                    rate = max(rate, 1e-6)
                    self._update_rate_norm(rate, 'V2V')
                    tx_time = task_data / rate if task_data > 0 else 0.0
                max_rate = self._get_norm_rate('V2V')
            else:
                queue_wait = 0.0
                cpu_freq = v.cpu_freq
                tx_time = 0.0
                max_rate = self._get_norm_rate('V2I')

            comp_time = task_comp / max(cpu_freq, 1e-6)
            max_tx_time = task_data / max(max_rate, 1e-6) if task_data > 0 else 1.0
            max_comp_time = task_comp / max(self.config.MIN_VEHICLE_CPU_FREQ, 1e-6)

            delay_norm = (tx_time / max(max_tx_time, 1e-6) +
                          queue_wait / max(self.config.NORM_MAX_WAIT_TIME, 1e-6) +
                          comp_time / max(max_comp_time, 1e-6))

            if tx_time > 0 and target != 'Local':
                tx_power_w = self.config.dbm2watt(v.tx_power_dbm)
                max_power_w = self.config.dbm2watt(self.config.TX_POWER_MAX_DBM)
                max_energy = max_power_w * max(max_tx_time, 1e-6)
                energy_norm = (tx_power_w * tx_time) / max(max_energy, 1e-6)

        if dag.deadline > 0:
            elapsed = self.time - dag.start_time
            deadline_abs = dag.start_time + dag.deadline
            
            # [Deadline检查计数] 每次检查都计数（不依赖logger）
            self._audit_deadline_checks += 1
            
            # [Deadline判定详细日志] 只在首次触发时打印（避免刷屏）
            if elapsed > dag.deadline and not dag.is_finished and not dag.is_failed:
                # [Deadline Miss计数] 记录miss次数（不依赖logger）
                self._audit_deadline_misses += 1
                # 计算first_ready_time（最早READY子任务的时间）
                first_ready_time = dag.start_time
                ready_status = dag.status >= 1  # READY或更高状态
                if np.any(ready_status):
                    # 使用EST作为first_ready_time的近似（EST在任务开始执行时设置）
                    est_values = dag.EST[dag.EST >= 0]
                    if len(est_values) > 0:
                        first_ready_time = float(np.min(est_values))
                
                # 记录deadline判定详情（仅首次触发）
                if not hasattr(dag, '_deadline_miss_logged'):
                    dag._deadline_miss_logged = True
                    if hasattr(self, '_logger') and self._logger:
                        self._logger.warning(
                            f"[Deadline Miss] Vehicle{v.id}, DAG{dag.id}:\n"
                            f"  now_time={self.time:.3f}s, deadline_abs={deadline_abs:.3f}s, "
                            f"start_time={dag.start_time:.3f}s, deadline_rel={dag.deadline:.3f}s\n"
                            f"  elapsed={elapsed:.3f}s, first_ready_time≈{first_ready_time:.3f}s\n"
                            f"  is_finished={dag.is_finished}, status_dist={np.bincount(dag.status)}\n"
                            f"  elapsed > deadline: {elapsed:.3f} > {dag.deadline:.3f} = {elapsed > dag.deadline}"
                        )
                
                overtime_ratio = (elapsed - dag.deadline) / dag.deadline
                r_timeout = -self.config.TIMEOUT_PENALTY_WEIGHT * np.tanh(self.config.TIMEOUT_STEEPNESS * overtime_ratio)
                dag.set_failed(reason='deadline')
                
                # [硬断言] 验证时间单位一致性
                assert abs(deadline_abs - (dag.start_time + dag.deadline)) < 1e-6, \
                    f"Deadline计算错误: {deadline_abs:.6f} != {dag.start_time:.6f} + {dag.deadline:.6f}"

        return {
            "delay_norm": delay_norm,
            "energy_norm": energy_norm,
            "r_soft_pen": r_soft_pen,
            "r_timeout": r_timeout,
            "hard_triggered": hard_triggered,
        }

    def _clip_reward(self, reward):
        """
        [奖励函数辅助] 奖励裁剪，防止奖励爆炸

        Args:
            reward: 原始奖励值

        Returns:
            float: 裁剪后的奖励值
        """
        if reward <= self.config.REWARD_MIN:
            pass  # 已清理
        if reward >= self.config.REWARD_MAX:
            pass  # 已清理
        return np.clip(reward, self.config.REWARD_MIN, self.config.REWARD_MAX)

    def calculate_agent_reward(self, vehicle_id, target, task_idx=None, data_size=0, task_comp=None, return_components=False, cft_prev_rem=None, cft_curr_rem=None, power_ratio=None, t_tx=None):
        """
        [MAPPO奖励函数] 计算单个智能体的奖励

        Args:
            vehicle_id: 车辆ID
            target: 卸载目标 ('Local', 'RSU', 或车辆ID)
            task_idx: 当前调度的任务索引
            data_size: 任务数据量 (bits)
            task_comp: 任务计算量 (cycles)

        Returns:
            float: 归一化后的奖励值
        """
        v = self.vehicles[vehicle_id]
        dag = v.task_dag

        v.last_success_bonus = 0.0
        illegal_flag = getattr(v, 'illegal_action', False)
        components = self._compute_cost_components(vehicle_id, target, task_idx, task_comp)
        hard_triggered = components.get("hard_triggered", False)

        snapshot_time = self.time
        if cft_prev_rem is None or cft_curr_rem is None:
            cft_abs = self._compute_mean_cft_pi0(snapshot_time=snapshot_time, vehicle_ids=[v.id])
            cft_prev_rem = max(cft_abs - snapshot_time, 0.0) if cft_abs is not None else 0.0
            cft_curr_rem = cft_prev_rem

        if power_ratio is None:
            power_ratio = self._power_ratio_from_dbm(getattr(v, "tx_power_dbm", getattr(Cfg, "TX_POWER_MIN_DBM", 0.0)))
        if t_tx is None:
            t_tx = 0.0
        t_tx = float(np.clip(t_tx, 0.0, self.config.DT))
        if target == 'Local':
            t_tx = 0.0
        p_max_watt = self._get_p_max_watt(target)
        dT_rem = cft_prev_rem - cft_curr_rem

        reward, parts = compute_absolute_reward(
            dT_rem,
            t_tx,
            power_ratio,
            self.config.DT,
            p_max_watt,
            self.config.REWARD_MIN,
            self.config.REWARD_MAX,
            hard_triggered=hard_triggered or illegal_flag,
            illegal_action=illegal_flag,
        )
        reward = self._clip_reward(reward)

        out_components = {
            "delay_norm": components.get("delay_norm", 0.0),
            "energy_norm": parts.get("energy_norm", 0.0),
            "r_soft_pen": components.get("r_soft_pen", 0.0),
            "r_timeout": components.get("r_timeout", 0.0),
            "hard_triggered": hard_triggered,
            "dT_eff": parts.get("dT_eff", 0.0),
            "t_tx": parts.get("t_tx", 0.0),
        }

        return (reward, out_components) if return_components else reward
    
    # ========================================================================
    # 审计系统方法
    # ========================================================================
    
    def _collect_audit_step_info(self, commit_plans):
        """
        收集本步的审计数据（12项核心指标）
        
        Args:
            commit_plans: 本步提交的action plans
            
        Returns:
            dict: 审计信息
        """
        audit_info = {}
        
        # (1) RSU mask可用性 - 从plan中统计
        rsu_available_count = 0
        for plan in commit_plans:
            # 检查RSU是否在本次决策中可用
            if plan['subtask_idx'] is not None:
                v = plan['vehicle']
                # 通过检查_last_rsu_choice判断RSU是否可用
                if self._last_rsu_choice.get(v.id) is not None:
                    rsu_available_count += 1
        audit_info['rsu_mask_true'] = rsu_available_count
        
        # (2) V2V可选邻居数 - 从_last_candidates统计
        valid_v2v_counts = []
        for plan in commit_plans:
            if plan['subtask_idx'] is not None:
                v = plan['vehicle']
                candidates = self._last_candidates.get(v.id, [])
                valid_count = sum(1 for cid in candidates if cid is not None and cid >= 0)
                valid_v2v_counts.append(valid_count)
        audit_info['valid_v2v_count'] = np.mean(valid_v2v_counts) if valid_v2v_counts else 0
        
        # (3) Illegal动作统计 - 从plan中提取
        for plan in commit_plans:
            if plan['illegal_reason'] is not None:
                v = plan['vehicle']
                target_idx = plan.get('target_idx', 0)
                
                # 判断action类型
                if target_idx == 0:
                    action_type = 'local'
                elif target_idx == 1:
                    action_type = 'rsu'
                else:
                    action_type = 'v2v'
                
                # 检查mask是否一致（critical check）
                mask_was_true = False
                if action_type == 'rsu':
                    mask_was_true = (self._last_rsu_choice.get(v.id) is not None)
                elif action_type == 'v2v':
                    candidates = self._last_candidates.get(v.id, [])
                    neighbor_idx = target_idx - 2
                    if 0 <= neighbor_idx < len(candidates):
                        mask_was_true = (candidates[neighbor_idx] is not None and candidates[neighbor_idx] >= 0)
                else:  # local
                    mask_was_true = True  # Local永远可用
                
                audit_info['illegal_action'] = True
                audit_info['action_type'] = action_type
                audit_info['illegal_reason'] = plan['illegal_reason']
                audit_info['mask_was_true'] = mask_was_true
                break  # 记录第一个illegal即可
        
        # (4) RSU队列长度
        if self.rsus:
            rsu_active_counts = []
            for rsu in self.rsus:
                active_len = rsu.get_num_active_tasks() if hasattr(rsu, 'get_num_active_tasks') else 0
                rsu_active_counts.append(active_len)
            audit_info['rsu_queue_len'] = np.mean(rsu_active_counts) if rsu_active_counts else 0
        
        return audit_info
    
    def _log_episode_stats(self, terminated, truncated):
        """
        记录episode统计信息到JSONL文件
        
        Args:
            terminated: 是否自然终止（所有任务完成）
            truncated: 是否被截断（时间限制）
        """
        if not hasattr(self, '_reward_stats'):
            return
        
        # 计算episode级统计
        episode_metrics = {}
        
        # 基本信息
        episode_metrics['episode_steps'] = self._episode_steps
        episode_metrics['terminated'] = terminated
        episode_metrics['truncated'] = truncated
        episode_metrics['seed'] = self.config.SEED if hasattr(self.config, 'SEED') else None
        episode_metrics['episode_time_seconds'] = self.time
        
        # 成功率统计
        episode_vehicle_count = len(self.vehicles)
        success_count = sum([1 for v in self.vehicles if v.task_dag.is_finished])
        episode_metrics['episode_vehicle_count'] = episode_vehicle_count
        episode_metrics['success_rate_end'] = success_count / max(episode_vehicle_count, 1)
        episode_metrics['task_success_rate'] = success_count / max(episode_vehicle_count, 1)
        episode_metrics['vehicle_success_rate'] = success_count / max(episode_vehicle_count, 1)
        
        # 子任务成功率
        total_subtasks = 0
        completed_subtasks = 0
        for v in self.vehicles:
            total_subtasks += v.task_dag.num_subtasks
            completed_subtasks += np.sum(v.task_dag.status == 3)
        episode_metrics['total_subtasks'] = total_subtasks
        episode_metrics['subtask_success_rate'] = (completed_subtasks / total_subtasks) if total_subtasks > 0 else 0.0
        
        # Deadline miss率
        deadline_miss_count = sum([1 for v in self.vehicles if hasattr(v.task_dag, 'deadline_missed') and v.task_dag.deadline_missed])
        episode_metrics['deadline_miss_rate'] = deadline_miss_count / max(episode_vehicle_count, 1)
        episode_metrics['audit_deadline_misses'] = deadline_miss_count
        
        # 决策分布
        if hasattr(self, '_decision_counts'):
            total_decisions = sum(self._decision_counts.values()) if self._decision_counts else 1
            episode_metrics['decision_frac_local'] = self._decision_counts.get('local', 0) / total_decisions
            episode_metrics['decision_frac_rsu'] = self._decision_counts.get('rsu', 0) / total_decisions
            episode_metrics['decision_frac_v2v'] = self._decision_counts.get('v2v', 0) / total_decisions
        
        # [P2性能统计] 服务率和空闲率
        if hasattr(self, '_p2_active_time') and hasattr(self, '_p2_idle_time'):
            total_time = self._p2_active_time + self._p2_idle_time
            if total_time > 0:
                episode_metrics['idle_fraction'] = self._p2_idle_time / total_time
                if self._p2_active_time > 0 and hasattr(self, '_p2_deltaW_active'):
                    episode_metrics['service_rate_when_active'] = self._p2_deltaW_active / self._p2_active_time
                else:
                    episode_metrics['service_rate_when_active'] = 0.0
            else:
                episode_metrics['idle_fraction'] = 0.0
                episode_metrics['service_rate_when_active'] = 0.0
        else:
            episode_metrics['idle_fraction'] = 0.0
            episode_metrics['service_rate_when_active'] = 0.0
        
        # 死锁统计
        deadlock_count = sum([1 for v in self.vehicles if hasattr(v, 'is_deadlocked') and v.is_deadlocked])
        episode_metrics['deadlock_vehicle_count'] = deadlock_count
        
        # 传输任务统计（从队列中统计）
        tx_created_count = 0
        same_node_no_tx_count = 0
        for v in self.vehicles:
            if hasattr(v, 'exec_locations'):
                for i, loc in enumerate(v.exec_locations):
                    if loc is not None and loc != 'Local' and loc != v.id:
                        tx_created_count += 1
                    elif loc == v.id or loc == 'Local':
                        same_node_no_tx_count += 1
        episode_metrics['tx_tasks_created_count'] = tx_created_count
        episode_metrics['same_node_no_tx_count'] = same_node_no_tx_count
        
        # 从reward_stats提取统计信息
        metrics_dict = {}
        for name, bucket in self._reward_stats.metrics.items():
            if bucket.count > 0:
                metrics_dict[name] = {
                    'mean': bucket.sum / bucket.count,
                    'p95': bucket.get_percentile(0.95) if hasattr(bucket, 'get_percentile') else None,
                    'count': bucket.count
                }
        
        # 保存到实例变量（供train.py使用）
        self._last_episode_metrics = episode_metrics.copy()
        
        # 写入JSONL文件
        jsonl_path = os.environ.get('REWARD_JSONL_PATH')
        if jsonl_path:
            try:
                with open(jsonl_path, 'a', encoding='utf-8') as f:
                    import json
                    record = {
                        'episode': getattr(self, 'episode_count', 0),
                        'metrics': metrics_dict,
                        **episode_metrics
                    }
                    f.write(json.dumps(record, ensure_ascii=True) + '\n')
            except Exception as e:
                pass  # 静默失败，不影响训练
    
