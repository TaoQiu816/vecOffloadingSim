# 奖励函数归一化与量纲分析

## 1. 奖励公式

```python
reward = DELTA_CFT_SCALE * dT_clipped - DELTA_CFT_ENERGY_WEIGHT * energy_norm
```

## 2. 各组件分析

### 2.1 时间收益部分 (`DELTA_CFT_SCALE * dT_clipped`)

**输入：**
- `dT_rem`: 剩余完成时间的变化 (秒)
- `dT_clipped`: 裁剪后的时间变化，范围 `[DELTA_CFT_CLIP_MIN, DELTA_CFT_CLIP_MAX]` = `[-1.0, 1.0]` (秒)

**缩放：**
- `DELTA_CFT_SCALE = 10.0`

**输出范围：**
- `10.0 * [-1.0, 1.0]` = `[-10.0, 10.0]`

**量纲：**
- 输入：秒 (s)
- 输出：无量纲（经过缩放）

**问题：**
✅ **已归一化**：`dT_clipped`被裁剪到`[-1.0, 1.0]`范围
✅ **量纲统一**：通过`DELTA_CFT_SCALE`转换为无量纲奖励值

---

### 2.2 能耗惩罚部分 (`DELTA_CFT_ENERGY_WEIGHT * energy_norm`)

**能耗计算：**
```python
e_step = (p_tx + p_circuit) * dt
e_max = max((p_watt + p_circuit) * dt, 1e-12)
energy_norm = clip(e_step / e_max, 0.0, 1.0)
```

其中：
- `p_tx = power_ratio * p_max_watt`
- `power_ratio`: 动作输出，范围 `[0, 1]`
- `p_max_watt`: 最大发射功率 (W)
- `p_circuit`: 电路功率 (W)
- `dt`: 时间步长 (s)

**归一化：**
- `energy_norm = e_step / e_max`
- 范围：`[0.0, 1.0]`

**缩放：**
- `DELTA_CFT_ENERGY_WEIGHT = 0.2`

**输出范围：**
- `0.2 * [0.0, 1.0]` = `[0.0, 0.2]`

**量纲：**
- 输入：焦耳 (J) = 瓦特 (W) × 秒 (s)
- 归一化后：无量纲 `[0, 1]`
- 输出：无量纲

**问题：**
✅ **已归一化**：能耗除以最大能耗，归一化到`[0, 1]`
✅ **量纲统一**：输出为无量纲奖励值

---

## 3. 最终奖励范围

### 3.1 理论范围（正常情况）

```
reward = 10.0 * dT_clipped - 0.2 * energy_norm
       = 10.0 * [-1.0, 1.0] - 0.2 * [0.0, 1.0]
       = [-10.0, 10.0] - [0.0, 0.2]
       = [-10.2, 10.0]
```

### 3.2 实际裁剪范围

```python
reward = clip(reward, REWARD_MIN, REWARD_MAX)
       = clip(reward, -25.0, 40.0)
```

**分析：**
- 理论范围 `[-10.2, 10.0]` 远小于裁剪范围 `[-25.0, 40.0]`
- 裁剪范围预留了额外空间，用于：
  - `SUCCESS_BONUS = 30.0`（任务成功奖励）
  - `PENALTY_FAILURE = -20.0`（任务失败惩罚）

---

## 4. 潜在问题分析

### 4.1 ⚠️ 量纲不一致问题

**时间收益部分：**
- `dT_clipped`的单位是**秒 (s)**
- 通过`DELTA_CFT_SCALE = 10.0`缩放
- 含义：**每节省0.1秒 = +1.0奖励**

**能耗惩罚部分：**
- `energy_norm`是**归一化值 [0, 1]**（无量纲）
- 通过`DELTA_CFT_ENERGY_WEIGHT = 0.2`缩放
- 含义：**最大功率 = -0.2奖励**

**问题：**
这两个部分的**物理意义不对等**：
- 时间部分：基于**绝对时间节省**（秒）
- 能耗部分：基于**相对能耗比例**（归一化）

**影响：**
1. **不同场景下权重不一致**：
   - 短任务（dt小）：时间变化小，能耗权重相对较大
   - 长任务（dt大）：时间变化大，能耗权重相对较小

2. **能耗惩罚可能过小**：
   - 最大能耗惩罚只有`0.2`
   - 而时间奖励可达`10.0`
   - 比例约为 `1:50`

---

### 4.2 ⚠️ `dT_clipped`的裁剪范围问题

**当前设置：**
```python
DELTA_CFT_CLIP_MIN = -1.0  # 秒
DELTA_CFT_CLIP_MAX = 1.0   # 秒
```

**问题：**
- 如果一步的时间节省超过1秒，会被裁剪
- 如果一步的时间损失超过1秒，也会被裁剪
- 这可能导致**信息丢失**和**梯度饱和**

**建议：**
- 检查实际训练中`dT_rem`的分布
- 如果经常触及边界，考虑调整裁剪范围或使用软裁剪（如tanh）

---

### 4.3 ✅ 能耗归一化正确

**当前实现：**
```python
energy_norm = e_step / e_max
```

**正确性：**
- ✅ 分子分母量纲一致（都是焦耳）
- ✅ 归一化到 `[0, 1]`
- ✅ 与动作无关的基准（`e_max`是固定的最大能耗）

---

## 5. 建议改进

### 5.1 统一量纲（推荐）

**方案A：将时间也归一化**
```python
# 归一化时间变化
dT_norm = dT_rem / dt  # 归一化到步长
dT_clipped = clip(dT_norm, -1.0, 1.0)

# 奖励公式
reward = DELTA_CFT_SCALE * dT_clipped - DELTA_CFT_ENERGY_WEIGHT * energy_norm
```

**优点：**
- 时间和能耗都是 `[0, 1]` 范围的归一化值
- 权重更直观（都是无量纲）
- 不同任务规模下权重一致

---

**方案B：将能耗也使用绝对值**
```python
# 使用绝对能耗（焦耳）
e_step = (p_tx + p_circuit) * dt
e_scale = 1.0  # 能耗缩放系数，例如1焦耳 = 1奖励单位

# 奖励公式
reward = DELTA_CFT_SCALE * dT_clipped - ENERGY_SCALE * e_step
```

**优点：**
- 时间和能耗都使用绝对物理量
- 权重直接反映物理意义（秒 vs 焦耳）

**缺点：**
- 需要重新调整权重
- 不同功率设置下需要重新平衡

---

### 5.2 检查`dT_rem`的实际分布

**建议：**
1. 在训练中记录`dT_rem`的统计信息（均值、标准差、最大/最小值）
2. 检查是否经常触及裁剪边界 `[-1.0, 1.0]`
3. 如果经常裁剪，考虑：
   - 扩大裁剪范围
   - 使用软裁剪（tanh）
   - 调整`DELTA_CFT_SCALE`

---

### 5.3 重新平衡时间与能耗权重

**当前比例：**
- 时间最大贡献：`10.0`
- 能耗最大惩罚：`0.2`
- 比例：`50:1`

**建议：**
- 根据实际需求调整`DELTA_CFT_ENERGY_WEIGHT`
- 如果希望更关注能耗，可以增大到 `0.5` 或 `1.0`
- 如果希望完全忽略能耗，可以设为 `0.0`

---

## 6. 总结

### ✅ 正确的部分
1. 能耗已正确归一化到 `[0, 1]`
2. 最终奖励有合理的裁剪范围
3. 代码实现了NaN/Inf保护

### ⚠️ 需要注意的问题
1. **量纲不统一**：时间用绝对值（秒），能耗用归一化值（无量纲）
2. **权重不平衡**：时间权重远大于能耗权重（50:1）
3. **裁剪范围**：需要验证`dT_rem`是否经常触及 `[-1.0, 1.0]` 边界

### 📋 建议行动
1. **短期**：记录训练中`dT_rem`和`energy_norm`的分布，验证当前设置是否合理
2. **中期**：考虑统一量纲（方案A或B）
3. **长期**：根据实际任务需求调整时间/能耗权重比例

